Repository: core
Files analyzed: 39
Total size: 152.5 KB

Directory structure:
aim.ts
index.ts
arithmetic.ts
compare.ts
fence.ts
index.ts
html.ts
react.ts
text.ts
ai.ts
conditionals.ts
flow.ts
group.ts
input.ts
loop.ts
media.ts
parallel.ts
set.ts
transform.ts
utils.ts
package.json
default.ts
index.ts
execute.ts
index.ts
process.ts
state.ts
converter.ts
index.ts
aim.test.ts
state.test.ts
tsconfig.build.json
tsconfig.json
tsup.config.ts
types.ts

================================================
File: aim.ts
================================================
import { functions, nodes, tags, type Schema } from "@markdoc/markdoc";
import * as jsEnvironment from "browser-or-node";
import {
	greaterThan,
	greaterThanOrEqual,
	includes,
	lessThan,
	lessThanOrEqual,
} from "markdoc/functions/compare";
import { add, divide, multiply, subtract } from "markdoc/functions/arithmetic";
import { fenceNode } from "markdoc/nodes/fence";
import { parser } from "markdoc/parser";
import { aiTag } from "markdoc/tags/ai";
import { elseTag, ifTag } from "markdoc/tags/conditionals";
import { flowTag } from "markdoc/tags/flow";
import { inputTag } from "markdoc/tags/input";
import { loopTag } from "markdoc/tags/loop";
import { setTag } from "markdoc/tags/set";
import { StateManager } from "runtime/state";
import { execute, executeGenerator } from "./runtime/execute";
import type { RuntimeOptions } from "./types";
import { mediaTag } from "markdoc/tags/media";
import { groupTag } from "markdoc/tags/group";
import { parallelTag } from "markdoc/tags/parallel";
export const GLOBAL_SCOPE = "global";

export const defaultRuntimeOptions: RuntimeOptions = {
	plugins: [],
	adapters: [],
	variables: {},
	input: {},
	events: {},
	tools: {},
	signals: {
		abort: new AbortController().signal,
	},
	timeout: 50000,
	maxRetries: 5,
	environment: jsEnvironment.isBrowser ? "browser" : "node",
	getReferencedFlow: undefined,
	settings: {
		useScoping: false,
	},
	env: {},
	config: {
		variables: {},
		nodes: {
			...nodes,
			fence: fenceNode,
		},
		tags: {
			...tags,
			ai: aiTag,
			loop: loopTag,
			set: setTag,
			input: inputTag,
			flow: flowTag,
			if: ifTag,
			else: elseTag,
			media: mediaTag,
			group: groupTag,
			parallel: parallelTag,
		},
		functions: {
			...functions,
			greaterThan,
			lessThan,
			greaterThanOrEqual,
			lessThanOrEqual,
			includes,
			add,
			subtract,
			multiply,
			divide,
		},
	},
};

export function aim({
	content,
	options = defaultRuntimeOptions,
	manager,
}: { content: string; options: RuntimeOptions; manager?: StateManager }) {

	const stateManager = manager || new StateManager(
		{
			...options.config,
			variables: {
				...options.config.variables,
			},
		},
		options,
	);

	stateManager.setSecrets(options.env || {});

	// Register plugins in state
	if (options.plugins) {
		for (const p of options.plugins) {
			stateManager.registerPlugin(p.plugin, p.options);
		}
	}

	if (options.adapters) {
		for (const adapter of options.adapters) {
			stateManager.registerAdapter(adapter);
		}
	}

	// Convert plugins to Markdoc tags
	const pluginsConvertedToMarkdocTags: Record<string, Schema> =
		options.plugins?.reduce((acc, p) => {
			const tags = Object.entries(p.plugin.tags || {}).reduce(
				(filtered, [key, tag]) => {
					const { runtime, ...tagWithoutRuntime } = tag as any;
					return {
						...filtered,
						[`${p.plugin.name}_${key}`]: tagWithoutRuntime,
					};
				},
				{},
			);
			return {
				...acc,
				...tags,
			};
		}, {}) || {};

	const runtimeOptions = {
		...defaultRuntimeOptions,
		...options,
		config: {
			...defaultRuntimeOptions.config,
			...options.config,
			tags: {
				...defaultRuntimeOptions.config.tags,
				...pluginsConvertedToMarkdocTags,
			},
		},
		events: {
			...defaultRuntimeOptions.events,
			...options.events,
		},
	};

	stateManager.$runtimeState.next({
		...stateManager.getRuntimeState(),
		options: runtimeOptions,
	});

	const { ast, validation, frontmatter } = parser(content, runtimeOptions);

	const warnings = validation.map((error) => ({
		...error,
		error: {
			...error.error,
			level:
				error.error?.id === "variable-undefined"
					? "warning"
					: error.error?.level,
		},
	}));

	const errors = validation.filter(
		(error) =>
			error.error?.level === "error" &&
			error.error?.id !== "variable-undefined",
	);

	return {
		ast,
		frontmatter,
		errors: errors,
		warnings: warnings,
		runtimeOptions,
		stateManager,
		execute: async (variables?: Record<string, any>) => {
			// Get input variables from document frontmatter
			const inputVariables = frontmatter?.input || [];
			const resolvedVariables: Record<string, any> = {};

			// First try to get values from passed variables, then options.input or options.variables
			const inputValues =
				variables || runtimeOptions.input || runtimeOptions.variables || {};

			// Map input variables using provided values or defaults from schema
			for (const variable of inputVariables) {
				const value = inputValues[variable.name];
				resolvedVariables[variable.name] = value ?? variable.schema?.default;
			}

			// Create a nested input object for frontmatter access
			const inputObject = {
				...inputValues, // Include all input values directly
			};

			if (Object.keys(inputObject).length > 0) {
				stateManager.pushStack({
					id: "frontmatter",
					variables: {
						...inputObject,
					},
					scope: GLOBAL_SCOPE,
				});
			}

			const timeoutPromise = new Promise((_, reject) => {
				setTimeout(
					() => reject(new Error("Execution timed out")),
					runtimeOptions.timeout,
				);
			});

			const abortPromise = new Promise((_, reject) => {
				runtimeOptions.signals.abort.addEventListener("abort", () =>
					reject(new Error("Execution aborted")),
				);
			});

			await Promise.race([
				execute({
					node: ast,
					stateManager,
				}),
				timeoutPromise,
				abortPromise,
			]);
		},
		executeWithGenerator: async function* (variables?: Record<string, any>) {
			// Get input variables from document frontmatter
			const inputVariables = frontmatter?.input || [];
			const resolvedVariables: Record<string, any> = {};

			// First try to get values from passed variables, then options.input or options.variables
			const inputValues =
				variables || runtimeOptions.input || runtimeOptions.variables || {};

			// Map input variables using provided values or defaults from schema
			for (const variable of inputVariables) {
				const value = inputValues[variable.name];
				resolvedVariables[variable.name] = value ?? variable.schema?.default;
			}

			// Create a nested input object for frontmatter access
			const inputObject = {
				...inputValues, // Include all input values directly
			};

			if (Object.keys(inputObject).length > 0) {
				stateManager.pushStack({
					id: "frontmatter",
					variables: {
						...inputObject,
					},
					scope: GLOBAL_SCOPE,
				});
			}

			const generator = executeGenerator({
				node: ast,
				stateManager,
			});

			const timeoutId = setTimeout(() => {
				generator.throw(new Error("Execution timed out"));
			}, runtimeOptions.timeout);

			try {
				for await (const result of generator) {
					if (runtimeOptions.signals.abort.aborted) {
						throw new Error("Execution aborted");
					}
					yield result;
				}
			} finally {
				clearTimeout(timeoutId);
			}
		},
	};
}

================================================
File: index.ts
================================================
export * from "./aim";
export * from "./runtime";
export * from "./types";
export * from "@markdoc/markdoc";

import { html } from "./markdoc/renderers/html";
import { react, reactStatic } from "./markdoc/renderers/react";
import { text } from "./markdoc/renderers/text";

export const renderers = {
	html: html,
	react: react,
	reactStatic: reactStatic,
	text: text,
} as const;



================================================
File: markdoc/functions/arithmetic.ts
================================================
import type { ConfigFunction } from "@markdoc/markdoc";

export const add: ConfigFunction = {
	parameters: {
		0: { required: true },
		1: { required: true },
	},
	transform(parameters: Record<string, unknown>) {
		const a = Number.parseInt(parameters[0] as string, 10);
		const b = Number.parseInt(parameters[1] as string, 10);
		return a + b;
	},
};

export const subtract: ConfigFunction = {
	parameters: {
		0: { required: true },
		1: { required: true },
	},
	transform(parameters: Record<string, unknown>) {
		const a = Number.parseInt(parameters[0] as string, 10);
		const b = Number.parseInt(parameters[1] as string, 10);
		return a - b;
	},
};

export const multiply: ConfigFunction = {
	parameters: {
		0: { required: true },
		1: { required: true },
	},
	transform(parameters: Record<string, unknown>) {
		const a = Number.parseInt(parameters[0] as string, 10);
		const b = Number.parseInt(parameters[1] as string, 10);
		return a * b;
	},
};

export const divide: ConfigFunction = {
	parameters: {
		0: { required: true },
		1: { required: true },
	},
	transform(parameters: Record<string, unknown>) {
		const a = Number.parseInt(parameters[0] as string, 10);
		const b = Number.parseInt(parameters[1] as string, 10);
		if (b === 0) {
			throw new Error("Division by zero");
		}
		return a / b;
	},
};



================================================
File: markdoc/functions/compare.ts
================================================
import type { ConfigFunction } from "@markdoc/markdoc";

export const greaterThan: ConfigFunction = {
	parameters: {
		0: { required: true },
		1: { required: true },
	},
	transform(parameters: Record<string, unknown>) {
		const a = Number.parseInt(parameters[0] as string, 10);
		const b = Number.parseInt(parameters[1] as string, 10);
		return a > b;
	},
};

export const lessThan: ConfigFunction = {
	parameters: {
		0: { required: true },
		1: { required: true },
	},
	transform(parameters: Record<string, unknown>) {
		const a = Number.parseInt(parameters[0] as string, 10);
		const b = Number.parseInt(parameters[1] as string, 10);
		return a < b;
	},
};

export const greaterThanOrEqual: ConfigFunction = {
	parameters: {
		0: { required: true },
		1: { required: true },
	},
	transform(parameters: Record<string, unknown>) {
		const a = Number.parseInt(parameters[0] as string, 10);
		const b = Number.parseInt(parameters[1] as string, 10);
		return a >= b;
	},
};

export const lessThanOrEqual: ConfigFunction = {
	parameters: {
		0: { required: true },
		1: { required: true },
	},
	transform(parameters: Record<string, unknown>) {
		const a = Number.parseInt(parameters[0] as string, 10);
		const b = Number.parseInt(parameters[1] as string, 10);
		return a <= b;
	},
};

export const includes: ConfigFunction = {
	parameters: {
		0: { required: true },
		1: { required: true },
	},
	transform(parameters: Record<string, unknown>) {
		const arr = parameters[0] as Array<unknown>;
		const value = parameters[1];
		return Array.isArray(arr) ? arr.includes(value) : false;
	},
};



================================================
File: markdoc/nodes/fence.ts
================================================
import { type Config, type Node, Tag, nodes } from "@markdoc/markdoc";
import { GLOBAL_SCOPE } from "aim";
import type { StateManager } from "runtime/state";

export const fenceNode = {
	...nodes.fence,
	attributes: {
		...nodes.fence.attributes,
		id: { type: String, required: false },
	},
};

export async function* fence(
	node: Node,
	config: Config,
	stateManager: StateManager,
) {
	const currentConfig = stateManager.getCurrentConfig(config);
	const attrs = node.transformAttributes(config);

	const fenceTag = new Tag("fence");
	yield fenceTag;

	const id = attrs.id || "code";

	let language = node.attributes.language;
	if (!language) {
		// Try to detect language from content
		const content = attrs.content || "";
		if (
			content.includes("console.log") ||
			content.includes("const ") ||
			content.includes("let ") ||
			content.includes("function")
		) {
			language = "javascript";
		} else if (
			content.includes("print(") ||
			content.includes("def ") ||
			content.includes("import ")
		) {
			language = "python";
		} else {
			language = "text";
		}
	}

	const adapter = stateManager.getAdapter("code");

	if (adapter) {
		try {
			const result = await adapter.handlers.eval({
				code: node.attributes.content,
				language,
				variables: currentConfig.variables,
			}, { manager: stateManager });

			const serializedResult = JSON.stringify(result) || '';

			stateManager.pushStack({
				id,
				scope: GLOBAL_SCOPE,
				variables: {
					result: serializedResult,
				}
			});

			fenceTag.children = [
				new Tag("code", { language }, [node.attributes.content]),
				result,
			];
		} catch (err) {
			stateManager.pushStack({
				id,
				scope: GLOBAL_SCOPE,
				variables: {
					result: '',
					error: JSON.stringify(err instanceof Error ? err.message : err),
					success: false
				}
			});
		}
	}
}



================================================
File: markdoc/parser/index.ts
================================================
import Markdoc, {
	type Config,
	type Node,
	type ValidateError,
} from "@markdoc/markdoc";
import yaml from "js-yaml";
import type { RuntimeOptions } from "../../types";

const getFrontmatter = (ast: Node) => {
	let frontmatter = {};
	try {
		const parsed = yaml.load(ast.attributes?.frontmatter);
		if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
			frontmatter = parsed as Record<string, any>;
		}
	} catch (err) {
		console.error("Error parsing frontmatter:", err);
	}
	return frontmatter;
};

export const parser = (
	input: string,
	options?: Partial<RuntimeOptions>,
): {
	ast: Node;
	validation: ValidateError[];
	config: Config;
	frontmatter: any;
} => {
	const tokenizer = new Markdoc.Tokenizer({
		allowComments: true,
		allowIndentation: true,
	});

	const tokens = tokenizer.tokenize(input);
	const ast = Markdoc.parse(tokens);

	const validation = Markdoc.validate(ast, options?.config);
	const frontmatter = getFrontmatter(ast);

	const _config = {
		...options?.config,
		variables: {
			...options?.config,
			frontmatter,
		},
	};

	return {
		ast,
		validation,
		config: _config,
		frontmatter,
	};
};



================================================
File: markdoc/renderers/html.ts
================================================
import { renderers, type RenderableTreeNode } from "@markdoc/markdoc";

export const html = (renderableTreeNodes: RenderableTreeNode[]): string => {
	return renderers.html(renderableTreeNodes);
};



================================================
File: markdoc/renderers/react.ts
================================================
import { renderers, type RenderableTreeNode } from "@markdoc/markdoc";
import type React from "react";

export const react = (
	renderableTreeNodes: RenderableTreeNode[],
	React: Readonly<{
		createElement: any;
		Fragment: any;
	}>,
	options?: {
		components?: Record<string, unknown>;
	},
): React.ReactNode => {
	return renderers.react(renderableTreeNodes, React, options);
};

export const reactStatic = (
	renderableTreeNodes: RenderableTreeNode[],
): React.ReactNode => {
	return renderers.reactStatic(renderableTreeNodes);
};



================================================
File: markdoc/renderers/text.ts
================================================
import { Tag, type RenderableTreeNodes } from "@markdoc/markdoc";

export const text = (
	renderableTreeNodes: RenderableTreeNodes | null,
): string => {
	if (!renderableTreeNodes) return "";

	let content = "";
	const nodes = Array.isArray(renderableTreeNodes)
		? renderableTreeNodes
		: [renderableTreeNodes];

	for (const node of nodes) {
		if (typeof node === "string") {
			content += node;
		} else if (typeof node === "number") {
			content += node.toString();
		} else if (Array.isArray(node)) {
			content += node
				.map((n) => {
					if (typeof n === "string") return n;
					if (typeof n === "number") return n.toString();
					if (Tag.isTag(n)) return n.children?.join("") || "";
					return "";
				})
				.join("");
		} else if (Tag.isTag(node)) {
			content += node.children?.join("") || "";
		}
	}

	return content;
};



================================================
File: markdoc/tags/ai.ts
================================================
import {
	type Config,
	type Node,
	type Schema,
	Tag,
	type RenderableTreeNodes,
} from "@markdoc/markdoc";
import { generateObject, generateText, type ToolExecutionOptions } from "ai";
import { GLOBAL_SCOPE } from "aim";
import { text } from "markdoc/renderers/text";
import type { StateManager } from "runtime/state";
import { createOpenAI } from "@ai-sdk/openai";
import { createAnthropic } from "@ai-sdk/anthropic";
import { createOllama } from "ollama-ai-provider";
import { chromeai as chromeAI } from "chrome-ai";
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { convertToAISDKTool } from "runtime/tools/converter";

export const aiTag: Schema = {
	render: "ai",
	selfClosing: true,
	attributes: {
		model: { type: String, required: true, default: "openai/gpt-4o-mini" },
		id: { type: String, required: false },
		temperature: { type: Number, required: false, default: 0.5 },
		structuredOutputs: { type: Object, required: false, default: undefined },
		tools: { type: String, required: false, default: undefined }, // array of tool names
	},
	transform(node, config) {
		return new Tag(
			"ai",
			node.transformAttributes(config),
			node.transformChildren(config),
		);
	},
};

export async function* ai(
	node: Node,
	config: Config,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;

	const attrs = node.transformAttributes(config);

	if (signal.aborted) {
		throw new Error("AI execution aborted");
	}

	const contextText = stateManager.getScopedText(GLOBAL_SCOPE).join("\n");
	const modelConfig = parseModelString(attrs.model || "openai/gpt-4");
	const model = await getAIModel(modelConfig, stateManager);
	const requestedTools = attrs.tools ? attrs.tools.split(",").map((t: string) => t.trim()) : undefined;

	if (!model) {
		throw new Error(`Invalid model configuration: ${attrs.model}`);
	}

	if (signal.aborted) {
		throw new Error("AI execution aborted");
	}

	const allTools = Object.fromEntries(
		Object.entries(stateManager.getRuntimeState().options.tools || {}).map(([name, tool]) => [name, convertToAISDKTool(tool)]),
	);

	const tools = attrs.tools === "*" ? allTools :
		requestedTools ? Object.fromEntries(
			Object.entries(allTools).filter(([name]) => requestedTools.includes(name))
		) : {};

	for (const [name, tool] of Object.entries(tools || {})) {
		if (tool?.execute) {
			const originalExecute = tool.execute;
			tool.execute = async (args: unknown, options: ToolExecutionOptions) => {
				const result = await originalExecute(args, options);

				stateManager.addToTextRegistry(
					`${name} called with args: ${JSON.stringify(args)}\nResult: ${JSON.stringify(result)}`,
					GLOBAL_SCOPE
				);

				return result;
			};
		}
		else {
			tool.execute = async (args: unknown) => {
				stateManager.runtimeOptions.events?.onToolCall?.(name, args);
			};
		}
	}

	const result = await generateText({
		model,
		prompt: contextText,
		temperature: attrs.temperature || 0.5,
		abortSignal: signal,
		tools: tools || {},
		maxSteps: 10,
	});

	stateManager.addToTextRegistry(text(result.text), GLOBAL_SCOPE);

	let structuredOutputs;
	if (attrs.structuredOutputs) {
		if (signal.aborted) {
			throw new Error("AI execution aborted");
		}

		const structuredOutputsRequest = await generateObject({
			model,
			prompt: `Create an object that matches the following schema: ${JSON.stringify(attrs.structuredOutputs)}\n Here is the context: ${stateManager.getScopedText(GLOBAL_SCOPE).join("\n")}`,
			temperature: attrs.temperature || 0.5,
			output: "no-schema",
			abortSignal: signal,
		});

		structuredOutputs = structuredOutputsRequest.object;

		if (structuredOutputs) {
			stateManager.addToTextRegistry(text(JSON.stringify(structuredOutputs)), GLOBAL_SCOPE);
		}
	}

	const aiTag = new Tag("ai");

	if (signal.aborted) {
		throw new Error("AI execution aborted");
	}

	stateManager.pushStack({
		id: attrs.id || "ai",
		scope: GLOBAL_SCOPE,
		variables: {
			result: result.text,
			context: contextText,
			...(structuredOutputs && { structuredOutputs }),
		},
	});

	aiTag.children.push(result.text);

	yield aiTag;
}

interface ModelConfig {
	provider: string;
	name: string;
	hosting?: string;
	extension?: string;
}

function parseModelString(modelString: string): ModelConfig {
	const [provider, fullModelName = ''] = modelString.split('/');
	const [modelNameWithExtension = '', hosting = ''] = fullModelName.split('@');
	const [modelName, extension = ''] = modelNameWithExtension.split(':');

	return {
		provider,
		name: extension ? `${modelName}:${extension}` : modelName,
		hosting,
		extension,
	};
}

async function getAIModel(config: ModelConfig, stateManager: StateManager) {
	if (config.hosting === "openrouter") {
		const openRouterClient = createOpenRouter({
			apiKey: stateManager.getSecret("OPENROUTER_API_KEY"),
		});
		return openRouterClient(`${config.provider}/${config.name}`);
	}

	switch (config.provider) {
		case "openai": {
			const openAIClient = createOpenAI({
				apiKey: stateManager.getSecret("OPENAI_API_KEY"),
			});
			return openAIClient(config.name);
		}
		case "anthropic": {
			const anthropicClient = createAnthropic({
				apiKey: stateManager.getSecret("ANTHROPIC_API_KEY"),
			});
			return anthropicClient(config.name);
		}
		case "ollama": {
			const ollamaClient = createOllama({
				baseURL: stateManager.getSecret("OLLAMA_BASE_URL"),
			});
			return ollamaClient(config.name);
		}
		case "google":
			if (config.name === "chrome-ai") {
				return chromeAI("text", { temperature: 0.5, topK: 5 });
			}
			throw new Error(`Unsupported Google model: ${config.name}`);
		default:
			throw new Error(`Unsupported model provider: ${config.provider}`);
	}
}

// export const modelProviders = {
// 	openai: [
// 		"gpt-3.5-turbo",
// 		"gpt-4",
// 		"gpt-4-turbo",
// 		"gpt-4-32k",
// 		"gpt-4-1106-preview",
// 		"gpt-4-vision-preview",
// 		"gpt-3.5-turbo-16k",
// 		"gpt-3.5-turbo-instruct",
// 	],
// 	google: [
// 		"gemini-pro",
// 		"gemini-pro-vision",
// 		"text-bison",
// 		"chat-bison",
// 		"code-bison",
// 		"codechat-bison",
// 	],
// 	anthropic: [
// 		"claude-2",
// 		"claude-2.1",
// 		"claude-3-opus",
// 		"claude-3-sonnet",
// 		"claude-3-haiku",
// 		"claude-instant-1",
// 		"claude-instant-1.2",
// 	],
// };

// export const allModels = Object.entries(modelProviders).flatMap(([provider, models]) =>
// 	models.map(model => `${provider}/${model}`)
// );



================================================
File: markdoc/tags/conditionals.ts
================================================
import {
	type Config,
	type Node,
	type RenderableTreeNodes,
	Tag,
	tags,
} from "@markdoc/markdoc";
import { GLOBAL_SCOPE } from "aim";
import { nanoid } from "nanoid";
import type { StateManager } from "runtime/state";
import { walk } from "runtime/process";

type Condition = { condition: any; children: any[]; type: "if" | "else" };

function renderConditions(node: any) {
	const conditions: Condition[] = [
		{ condition: node.attributes.primary, children: [], type: "if" },
	];
	for (const child of node.children) {
		if (child.type === "tag" && child.tag === "else")
			conditions.push({
				condition:
					"primary" in child.attributes ? child.attributes.primary : true,
				children: [],
				type: "else",
			});
		else conditions[conditions.length - 1].children.push(child);
	}
	return conditions;
}

export const ifTag = {
	...tags.if,
	transform(node: Node, config: Config) {
		const attrs = node.transformAttributes(config);
		const conditions = renderConditions(node);
		const tags = [];

		for (const { condition, children: conditionChildren, type } of conditions) {
			if (type === "if") {
				tags.push(
					new Tag(
						"if",
						{
							...attrs,
							"data-condition": condition,
						},
						conditionChildren.map(
							(child) => child.transform?.(config) || child,
						),
					),
				);
			} else {
				tags.push(
					new Tag(
						"else",
						{
							...attrs,
							"data-condition": condition,
						},
						conditionChildren.map(
							(child) => child.transform?.(config) || child,
						),
					),
				);
			}
		}

		return tags;
	},
};
export const elseTag = tags.else;

export async function* if_(
	node: Node,
	config: Config,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;

	const attrs = node.transformAttributes(config);
	const conditions = renderConditions(node);

	const ifTag = new Tag("if");

	// Check abort signal before processing
	if (signal.aborted) {
		throw new Error("If execution aborted");
	}

	const children = [];
	const id = attrs.id || nanoid();

	for (const { condition, children: conditionChildren, type } of conditions) {
		// Check abort signal before evaluating each condition
		if (signal.aborted) {
			throw new Error("If execution aborted");
		}

		const resolvedCondition = condition?.resolve
			? condition.resolve(config)
			: condition;

		if (resolvedCondition) {
			stateManager.pushStack({
				id,
				scope: GLOBAL_SCOPE,
				variables: {
					condition: resolvedCondition,
					isTrue: true,
					branch: type,
				},
			});

			// Check abort signal before processing children
			if (signal.aborted) {
				throw new Error("If execution aborted");
			}

			for (const child of conditionChildren) {
				for await (const result of walk(child, stateManager)) {
					// Check abort signal during child processing
					if (signal.aborted) {
						throw new Error("If execution aborted");
					}
					children.push(result);
				}
			}

			break;
		}
	}

	// Check abort signal before finalizing
	if (signal.aborted) {
		throw new Error("If execution aborted");
	}

	ifTag.children = children.flat();

	yield ifTag;
}



================================================
File: markdoc/tags/flow.ts
================================================
import { openai } from "@ai-sdk/openai";
import {
	Tag,
	type Config,
	type Node,
	type Schema,
	type RenderableTreeNodes,
} from "@markdoc/markdoc";
import { generateObject } from "ai";
import { aim, GLOBAL_SCOPE, type StateManager } from "index";
import { nanoid } from "nanoid";

export const flowTag: Schema = {
	render: "flow",
	selfClosing: true,
	attributes: {
		path: { type: String, required: true },
		id: { type: String, required: false },
		input: { type: Object, required: false },
	},
	transform(node, config) {
		return new Tag(
			"flow",
			node.transformAttributes(config),
			node.transformChildren(config),
		);
	},
};

export async function* flow(
	node: Node,
	config: Config,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;

	const attrs = node.transformAttributes(config);
	const flowTag = new Tag("flow");

	if (signal.aborted) {
		throw new Error("Flow execution aborted");
	}

	const path = attrs.path;
	const id = attrs.id || nanoid();

	if (!path) {
		throw new Error("Flow tag must have a path attribute");
	}

	try {
		if (signal.aborted) {
			throw new Error("Flow execution aborted");
		}

		let flowContent: string;

		// TODO: get flow content from external resources (files, urls, etc)
		// for now we get the content from the runtime options
		flowContent = runtimeState.options.experimental_files?.[path]?.content || "";

		if (signal.aborted) {
			throw new Error("Flow execution aborted");
		}

		const { executeWithGenerator, frontmatter } = aim({
			content: flowContent,
			options: {
				...runtimeState.options,
			},
			manager: stateManager,
		});

		// if (errors && errors.length > 0) {
		// 	throw new Error(`Flow compilation errors: ${errors.join(", ")}`);
		// }

		let input = {};
		if (attrs.input) {
			input = attrs.input;
		} else if (frontmatter?.input) {
			const contextText = stateManager.getScopedText(GLOBAL_SCOPE).join("\n");

			const generatedInput = await generateObject({
				model: openai("gpt-4o-mini"),
				prompt: `Create an object that matches the following schema: ${JSON.stringify(frontmatter.input)}\n Here is the context: ${contextText}`,
				temperature: attrs.temperature || 0.5,
				output: "no-schema",
				abortSignal: signal,
			});

			input = generatedInput.object || {};
		}

		flowTag.children = [`Called flow (${path}) with input: ${JSON.stringify(input)}`];

		yield flowTag;

		for await (const result of executeWithGenerator({
			input: { ...input },
		})) {
			yield result as RenderableTreeNodes;
		}

		if (signal.aborted) {
			throw new Error("Flow execution aborted");
		}

		stateManager.pushStack({
			id,
			scope: GLOBAL_SCOPE,
			variables: {
				...input,
				path,
				content: flowContent,
			},
		});

	} catch (error) {
		throw new Error(`Failed to execute flow '${path}': ${error}`);
	}
}



================================================
File: markdoc/tags/group.ts
================================================
import {
	type Schema,
	type Node,
	type Config,
	Tag,
	type RenderableTreeNodes,
} from "@markdoc/markdoc";
import { type StateManager, walk } from "runtime";

export const groupTag: Schema = {
	render: "group",
	attributes: {
		id: { type: String, required: false },
	},
	transform(node, config) {
		return new Tag(
			"group",
			node.transformAttributes(config),
			node.transformChildren(config),
		);
	},
};

export async function* group(
	node: Node,
	config: Config,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const groupTag = new Tag("group");

	// Process child nodes
	for (const child of node.children) {
		for await (const result of walk(child, stateManager)) {
			if (Array.isArray(result)) {
				groupTag.children.push(...result);
			} else {
				groupTag.children.push(result);
			}
		}
	}

	yield groupTag;
}



================================================
File: markdoc/tags/input.ts
================================================
import {
	Tag,
	type Config,
	type Node,
	type Schema,
	type RenderableTreeNodes,
} from "@markdoc/markdoc";
import { GLOBAL_SCOPE } from "aim";
import { resolveValue } from "markdoc/utils";
import type { StateManager } from "runtime/state";

export const inputTag: Schema = {
	render: "input",
	selfClosing: true,
	attributes: {
		name: { type: String, required: false, default: "question" },
		description: { type: String, required: false, default: "" },
		type: { type: String, required: false, default: "text/plain" },
		src: { type: String, required: false },
	},
	transform(node, config) {
		return new Tag(
			"input",
			node.transformAttributes(config),
			node.transformChildren(config),
		);
	},
};

export async function* input(
	node: Node,
	config: Config,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;

	const attrs = node.transformAttributes(config);

	const inputTag = new Tag("input");

	// Check abort signal before processing
	if (signal.aborted) {
		throw new Error("Input execution aborted");
	}

	const name = resolveValue(attrs.name, config);
	const description = resolveValue(attrs.description, config);
	let type = resolveValue(attrs.type, config);
	const src = resolveValue(attrs.src, config);

	// Validate src if provided
	if (
		src &&
		!src.startsWith("file://") &&
		!src.startsWith("http://") &&
		!src.startsWith("https://")
	) {
		throw new Error("Source must start with file://, http://, or https://");
	}

	// Determine type from src extension if provided
	if (src) {
		const fileExtension = src.split(".").pop()?.toLowerCase();
		switch (fileExtension) {
			case "json":
				type = "application/json";
				break;
			case "txt":
				type = "text/plain";
				break;
			case "csv":
				type = "text/csv";
				break;
			case "pdf":
				type = "application/pdf";
				break;
			case "jpg":
			case "jpeg":
				type = "image/jpeg";
				break;
			case "png":
				type = "image/png";
				break;
		}
	}

	// Check abort signal before handling input
	if (signal.aborted) {
		throw new Error("Input execution aborted");
	}

	// TODO: Handle user input
	const inputValue = "test";

	if (inputValue) {
		stateManager.pushStack({
			id: name,
			scope: GLOBAL_SCOPE,
			variables: {
				value: inputValue,
				type,
				description,
			},
		});
	}

	inputTag.children = [
		JSON.stringify({
			name,
			description,
			type,
			src,
			value: inputValue,
		}),
	];

	yield inputTag;
}



================================================
File: markdoc/tags/loop.ts
================================================
import {
	type Schema,
	type Node,
	type Config,
	Tag,
	type RenderableTreeNodes,
} from "@markdoc/markdoc";
import { resolveValue } from "markdoc/utils";
import { type StateManager, walk } from "runtime";
import { GLOBAL_SCOPE } from "index";

export function truthy(value: any) {
	return value !== false && value !== undefined && value !== null;
}

const DEFAULT_ID = "loop";

export const loopTag: Schema = {
	render: "loop",
	attributes: {
		count: { type: Number, required: false },
		id: { type: String, required: false },
		items: { type: Array, required: false },
		primary: { type: Object, required: false },
	},
	transform(node, config) {
		return new Tag(
			"loop",
			node.transformAttributes(config),
			node.transformChildren(config),
		);
	},
};

export async function* loop(
	node: Node,
	config: Config,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;

	const attrs = node.transformAttributes(config);

	const count = resolveValue(attrs.count, config);
	const items = resolveValue(attrs.items, config);
	const condition = attrs.primary;

	const id = resolveValue(attrs?.id, config) || DEFAULT_ID;

	// Validate we have exactly one of: items, count, or condition
	const numericCount =
		typeof count === "number" ? count : Number.parseInt(count || "0", 10);
	const hasValidCount =
		typeof numericCount === "number" &&
		!isNaN(numericCount) &&
		numericCount > 0;
	const hasItems = Array.isArray(items) && items.length > 0;
	const hasCondition = condition !== undefined && condition !== null;

	// Validate that only one loop type is specified
	const loopTypes = [hasValidCount, hasItems, hasCondition].filter(
		Boolean,
	).length;
	if (loopTypes === 0) {
		throw new Error("Loop must specify either count, items, or a condition");
	}
	if (loopTypes > 1) {
		throw new Error(
			"Loop cannot specify multiple of: count, items, or condition",
		);
	}

	const iterables =
		items || (hasValidCount ? Array.from({ length: numericCount }) : [null]);
	let i = 0;

	// Initialize loop state before first iteration
	const updateLoopState = () => {
		stateManager.pushStack({
			id,
			scope: GLOBAL_SCOPE,
			variables: {
				index: i,
				count: i + 1,
				isFirst: i === 0,
				isLast: hasItems ? i === iterables.length - 1 : i === numericCount - 1,
				item: hasItems ? iterables[i] : undefined,
			},
		});
	};

	updateLoopState();

	do {
		// Check abort signal at start of each iteration
		if (signal.aborted) {
			throw new Error("Loop execution aborted");
		}

		// Process child nodes
		for (const child of node.children) {
			for await (const result of walk(child, stateManager)) {
				if (Array.isArray(result)) {
					yield* result;
				} else {
					yield result;
				}
			}
		}

		i++;

		// Handle loop termination
		if (!hasCondition && i >= iterables.length) {
			break;
		}

		// Update state for next iteration
		updateLoopState();

		// Evaluate condition for condition-based loops
		if (hasCondition) {
			const currentConfig = stateManager.getCurrentConfig(config);
			const resolvedCondition = resolveValue(condition, currentConfig);
			if (!truthy(resolvedCondition)) {
				break;
			}
		}
	} while (true);

	// Clean up loop state
	// stateManager.popStack(GLOBAL_SCOPE);
}



================================================
File: markdoc/tags/media.ts
================================================
import {
	Tag,
	type Config,
	type Node,
	type Schema,
	type RenderableTreeNodes,
} from "@markdoc/markdoc";
import { GLOBAL_SCOPE } from "aim";
import type { StateManager } from "runtime/state";

export const mediaTag: Schema = {
	render: "media",
	selfClosing: true,
	attributes: {
		src: { type: String, required: true },
		type: { type: String, required: false },
		description: { type: String, required: false },
		id: { type: String, required: false },
	},
	transform(node, config) {
		return new Tag(
			"media",
			node.transformAttributes(config),
			node.transformChildren(config),
		);
	},
};

export async function* media(
	node: Node,
	config: Config,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;

	const attrs = node.transformAttributes(config);

	const mediaTag = new Tag("media");

	// Check abort signal before processing
	if (signal.aborted) {
		throw new Error("Media loading aborted");
	}

	const src = attrs.src;
	let type = attrs.type;
	const description = attrs.description;
	const id = attrs.id || "media";

	// Validate src
	if (
		!src.startsWith("file://") &&
		!src.startsWith("http://") &&
		!src.startsWith("https://")
	) {
		throw new Error("Source must start with file://, http://, or https://");
	}

	// Determine type from src extension if not provided
	if (!type) {
		const fileExtension = src.split(".").pop()?.toLowerCase();
		switch (fileExtension) {
			case "jpg":
			case "jpeg":
				type = "image/jpeg";
				break;
			case "png":
				type = "image/png";
				break;
			case "gif":
				type = "image/gif";
				break;
			case "mp4":
				type = "video/mp4";
				break;
			case "mp3":
				type = "audio/mpeg";
				break;
			case "wav":
				type = "audio/wav";
				break;
			case "pdf":
				type = "application/pdf";
				break;
			default:
				type = "application/octet-stream";
		}
	}

	// Check abort signal before loading media
	if (signal.aborted) {
		throw new Error("Media loading aborted");
	}

	// TODO: Implement actual media loading logic here
	const mediaContent = {
		src,
		type,
		description,
		content: null, // This would be the actual loaded media content
	};

	stateManager.pushStack({
		id,
		scope: GLOBAL_SCOPE,
		variables: {
			src,
			type,
			description,
			content: mediaContent,
		},
	});

	mediaTag.children = [JSON.stringify(mediaContent)];

	yield mediaTag;
}



================================================
File: markdoc/tags/parallel.ts
================================================
import {
	type Schema,
	type Node,
	type Config,
	Tag,
	type RenderableTreeNodes,
} from "@markdoc/markdoc";
import { type StateManager, walk } from "runtime";
import { GLOBAL_SCOPE } from "index";

export const parallelTag: Schema = {
	render: "parallel",
	attributes: {
		id: { type: String, required: false },
	},
	transform(node, config) {
		return new Tag(
			"parallel",
			node.transformAttributes(config),
			node.transformChildren(config),
		);
	},
};

export async function* parallel(
	node: Node,
	config: Config,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;

	const attrs = node.transformAttributes(config);
	const id = attrs?.id || "parallel";

	const parallelTag = new Tag("parallel");

	// Check abort signal before processing
	if (signal.aborted) {
		throw new Error("Parallel execution aborted");
	}

	// Create an array of promises for each child node
	const childPromises = node.children.map(async (child) => {
		const results = [];
		for await (const result of walk(child, stateManager)) {
			// Check abort signal during child processing
			if (signal.aborted) {
				throw new Error("Parallel execution aborted");
			}

			if (Array.isArray(result)) {
				results.push(...result);
			} else {
				results.push(result);
			}
		}
		return results;
	});

	// Execute all children in parallel with abort handling
	const results = await Promise.race([
		Promise.all(childPromises),
		new Promise<never>((_, reject) => {
			signal.addEventListener("abort", () =>
				reject(new Error("Parallel execution aborted")),
			);
		}),
	]);

	// Check abort signal before finalizing
	if (signal.aborted) {
		throw new Error("Parallel execution aborted");
	}

	// Flatten and add all results to parallel tag children
	parallelTag.children = results.flat();

	stateManager.pushStack({
		id,
		scope: GLOBAL_SCOPE,
		variables: {
			results: results.flat(),
		},
	});

	yield parallelTag;
}



================================================
File: markdoc/tags/set.ts
================================================
import {
	Tag,
	type Config,
	type Node,
	type Schema,
	type RenderableTreeNodes,
} from "@markdoc/markdoc";
import { GLOBAL_SCOPE } from "aim";
import { resolveValue } from "markdoc/utils";
import type { StateManager } from "runtime/state";

export const setTag: Schema = {
	render: "set",
	selfClosing: true,
	attributes: {
		id: { type: String, required: true },
	},
	transform(node, config) {
		return new Tag(
			"set",
			node.transformAttributes(config),
			node.transformChildren(config),
		);
	},
};

export async function* set(
	node: Node,
	config: Config,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;

	const attrs = node.transformAttributes(config);

	const id = attrs.id;
	if (!id) {
		throw new Error("Set tag must have an id attribute");
	}

	const setTag = new Tag("set");

	// Check abort signal before processing
	if (signal.aborted) {
		throw new Error("Set execution aborted");
	}

	const variables = Object.fromEntries(
		Object.entries(node.attributes)
			.filter(([key]) => key !== "id")
			.map(([key, value]) => [key, resolveValue(value, config)]),
	);

	// Check abort signal before pushing state
	if (signal.aborted) {
		throw new Error("Set execution aborted");
	}

	stateManager.pushStack({
		id,
		variables,
		scope: GLOBAL_SCOPE,
	});

	// Check abort signal before finalizing
	if (signal.aborted) {
		throw new Error("Set execution aborted");
	}

	setTag.children = [JSON.stringify(variables)];

	// const children = [];
	// for (const child of node.children) {
	//     for await (const result of walk(child)) {
	//         children.push(result);
	//     }
	// }

	// setTag.children = children.flat();

	yield setTag;
}



================================================
File: markdoc/transform.ts
================================================
import Markdoc, { type Config, type Node } from "@markdoc/markdoc";

export async function transform(node: Node, config: Config) {
	return await Markdoc.transform(node, config);
}



================================================
File: markdoc/utils.ts
================================================
export function resolveValue(value: any, context: any): any {
	// Handle null/undefined
	if (value == null) {
		return value;
	}

	// Handle primitive types
	if (typeof value !== "object") {
		return value;
	}

	// Handle Markdoc Function type
	if ("$$mdtype" in value && value.$$mdtype === "Function") {
		// Resolve any variables in the function parameters first
		const resolvedParams = Object.fromEntries(
			Object.entries(value.parameters).map(([k, v]) => [
				k,
				resolveValue(v, context),
			]),
		);
		// Create new function object with resolved parameters
		const resolvedFunction = Object.create(value);
		resolvedFunction.parameters = resolvedParams;
		return resolvedFunction.resolve(context);
	}

	// Handle Markdoc Variable type
	if ("$$mdtype" in value && value.$$mdtype === "Variable") {
		const path = value.path;
		let resolvedValue = context.variables;
		for (const segment of path) {
			if (resolvedValue && typeof resolvedValue === "object") {
				resolvedValue = resolvedValue[segment];
			} else {
				resolvedValue = undefined;
				break;
			}
		}
		return resolvedValue;
	}

	// Handle arrays recursively
	if (Array.isArray(value)) {
		return value.map((item) => resolveValue(item, context));
	}

	// Handle objects recursively
	if (typeof value === "object") {
		return Object.fromEntries(
			Object.entries(value).map(([k, v]) => [k, resolveValue(v, context)]),
		);
	}

	return value;
}



================================================
File: package.json
================================================
{
  "name": "@aim-sdk/core",
  "version": "0.0.31",
  "main": "./dist/index.cjs",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "type": "module",
  "devDependencies": {
    "@types/bun": "^1.2.4",
    "@types/js-yaml": "^4.0.9",
    "@types/react": "^19.0.7",
    "tsup": "^8.3.6"
  },
  "peerDependencies": {
    "typescript": "^5.7.3"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.0.6",
    "@ai-sdk/openai": "^1.0.11",
    "@markdoc/markdoc": "^0.4.0",
    "@openrouter/ai-sdk-provider": "0.2.1",
    "@sebastianwessel/quickjs": "^1.3.0",
    "ai": "^4.1.1",
    "browser-or-node": "^3.0.0",
    "chrome-ai": "^1.11.1",
    "js-yaml": "^4.1.0",
    "langchain": "^0.3.15",
    "nanoid": "^5.0.9",
    "ollama-ai-provider": "^1.0.0",
    "react": "^19.0.0",
    "rxjs": "^7.8.1",
    "zod": "^3.24.1"
  },
  "publishConfig": {
    "access": "public"
  },
  "scripts": {
    "typecheck": "tsc --noEmit",
    "build": "rm -rf dist && tsup --config tsup.config.ts",
    "logs": "bun test/test-logs/index.ts",
    "test": "bun test",
    "check-deps": "bunx knip || exit 0"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.js"
    },
    "./types": {
      "types": "./dist/types.d.ts",
      "import": "./dist/types.mjs",
      "require": "./dist/types.js"
    }
  },
  "files": [
    "dist"
  ]
}


================================================
File: runtime/envs/default.ts
================================================
export const baseEnvVars = [
	{
		key: "OPENAI_API_KEY",
		info: "OpenAI API key",
		link: "https://platform.openai.com/api-keys",
	},
	{ key: "EXA_API_KEY", info: "Exa API key", link: "https://exa.ai/api-keys" },
	{
		key: "ANTHROPIC_API_KEY",
		info: "Anthropic API key",
		link: "https://console.anthropic.com/keys",
	},
	{
		key: "REPLICATE_API_KEY",
		info: "Replicate.com API key",
		link: "https://replicate.com",
	},
	{
		key: "OLLAMA_BASE_URL",
		info: "Ollama Host URL",
		link: "https://gist.github.com/microchipgnu/47333c621e18517305ddd888b877ea75",
		default: "http://127.0.0.1:11434/api",
	},
	{
		key: "OPENROUTER_API_KEY",
		info: "OpenRouter API key",
		link: "https://openrouter.ai/keys",
	},
];



================================================
File: runtime/envs/index.ts
================================================
import { baseEnvVars } from "./default";

export const getEnvValue = (key: string): string | undefined => {
	// Check process.env first (includes .env file variables)
	if (typeof process !== "undefined" && process.env && process.env[key]) {
		return process.env[key];
	}

	// If not found in localStorage, check for default value
	const defaultEnv = baseEnvVars.find((env) => env.key === key);
	return defaultEnv?.default;
};

export const getAllEnvVars = (): Record<string, string> => {
	const envVars: Record<string, string> = {};

	// Add all process.env variables (includes .env file variables)
	if (typeof process !== "undefined" && process.env) {
		Object.keys(process.env).forEach((key) => {
			envVars[key] = process.env[key] as string;
		});
	}

	// Add default values for any missing variables
	baseEnvVars.forEach((env) => {
		if (!envVars[env.key] && env.default) {
			envVars[env.key] = env.default;
		}
	});

	return envVars;
};



================================================
File: runtime/execute.ts
================================================
import * as jsEnvironment from "browser-or-node";
import { process as runtimeProcess } from "./process";
import type { AIMRuntime } from "../types";

async function handleAbortError(error: unknown, stateManager: any) {
	const isAbortError =
		(jsEnvironment.isBrowser &&
			error instanceof DOMException &&
			error.name === "AbortError") ||
		(jsEnvironment.isNode &&
			error instanceof Error &&
			error.name === "AbortError");

	if (isAbortError) {
		stateManager.runtimeOptions.events?.onAbort?.("Execution aborted!");
	} else {
		stateManager.runtimeOptions.events?.onError?.(`Execution error: ${error}`);
	}
	throw error;
}

async function checkAbortSignal(signal: AbortSignal) {
	if (signal.aborted) {
		throw new Error("Execution aborted");
	}
}

async function* processResults({
	node,
	stateManager,
	signal,
}: AIMRuntime & { signal: AbortSignal }) {
	const generator = runtimeProcess({ node, stateManager });

	for await (const result of generator) {
		await checkAbortSignal(signal);

		if (result) {
			stateManager.runtimeOptions.events?.onLog?.(
				`Processing result: ${JSON.stringify(result)}`,
			);
			stateManager.runtimeOptions.events?.onData?.(result);

			if (typeof result === "string" || typeof result === "object") {
				yield result;
			}
		}
	}
}

export const execute = async ({
	node,
	stateManager,
}: AIMRuntime): Promise<void> => {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;
	const options = runtimeState.options;
	options.variables = options.variables || {};

	await checkAbortSignal(signal);
	stateManager.runtimeOptions?.events?.onStart?.("Execution started!");

	const results: (string | object)[] = [];

	try {
		for await (const result of processResults({ node, stateManager, signal })) {
			results.push(result);
		}

		await checkAbortSignal(signal);
		stateManager.runtimeOptions.events?.onFinish?.("Execution finished!");
		stateManager.runtimeOptions.events?.onSuccess?.(
			"Execution completed successfully!",
		);
	} catch (error) {
		await handleAbortError(error, stateManager);
	}
};

export async function* executeGenerator({
	node,
	stateManager,
}: AIMRuntime): AsyncGenerator<string | object> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;
	const options = runtimeState.options;
	options.variables = options.variables || {};

	await checkAbortSignal(signal);
	stateManager.runtimeOptions?.events?.onStart?.("Execution started!");

	try {
		yield* processResults({ node, stateManager, signal });

		await checkAbortSignal(signal);
		stateManager.runtimeOptions.events?.onFinish?.("Execution finished!");
		stateManager.runtimeOptions.events?.onSuccess?.(
			"Execution completed successfully!",
		);
	} catch (error) {
		await handleAbortError(error, stateManager);
	}
}



================================================
File: runtime/index.ts
================================================
export * from "./process";
export * from "./state";
export * from "./envs/default";
export * from "./envs";



================================================
File: runtime/process.ts
================================================
import {
	Tag,
	type Node,
	type RenderableTreeNode,
	type RenderableTreeNodes,
} from "@markdoc/markdoc";
import { GLOBAL_SCOPE } from "aim";
import { fence } from "markdoc/nodes/fence";
import { text } from "markdoc/renderers/text";
import { ai } from "markdoc/tags/ai";
import { if_ } from "markdoc/tags/conditionals";
import { flow } from "markdoc/tags/flow";
import { input } from "markdoc/tags/input";
import { loop } from "markdoc/tags/loop";
import { set } from "markdoc/tags/set";
import { transform } from "markdoc/transform";
import type { AIMRuntime } from "types";
import type { StateManager } from "./state";
import { parallel } from "markdoc/tags/parallel";
import { media } from "markdoc/tags/media";
import { group } from "markdoc/tags/group";

export async function* walk(
	node: Node,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const signal = runtimeState.options.signals.abort;

	if (signal.aborted) {
		throw new Error("Operation aborted");
	}

	const config = stateManager.getCurrentConfig(runtimeState.options.config);

	switch (node.type) {
		case "paragraph":
		case "heading":
		case "list":
		case "item":
		case "inline":
			yield* handleContainerNode(node, config, stateManager);
			break;
		case "text":
			yield* handleTextNode(node, config, runtimeState);
			break;
		case "fence":
			yield* fence(node, config, stateManager);
			break;
		case "tag":
			yield* handleTag(node, stateManager);
			break;
		default:
			break;
	}
}

async function* handleContainerNode(
	node: Node,
	config: any,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const children = [];

	// Process all children first to get renderable tree nodes
	for (const child of node.children) {
		if (child.type === "text") {
			for await (const result of handleTextNode(
				child,
				config,
				stateManager.getRuntimeState(),
			)) {
				children.push(result);
			}
		} else {
			for await (const result of walk(child, stateManager)) {
				children.push(result);
			}
		}
	}
	// TODO: Need to recreate node because https://github.com/markdoc/markdoc/commit/2e2d2c4f6736300d0973b833b78e7b6a797357ea hasn't been released yet
	// Clone the node while preserving prototype chain
	const clonedNode = Object.create(
		Object.getPrototypeOf(node),
		Object.getOwnPropertyDescriptors(node),
	);
	clonedNode.children = [];

	const transformedNode = clonedNode.transform(config);

	let containerTag: Tag;

	if (Tag.isTag(transformedNode)) {
		// If transformedNode is a Tag, use its properties
		containerTag = new Tag(
			transformedNode.name,
			transformedNode.attributes,
			children.flat() as RenderableTreeNode[],
		);
	} else {
		// Otherwise fall back to node properties
		containerTag = new Tag(
			node.type,
			node.transformAttributes(config),
			children.flat() as RenderableTreeNode[],
		);
	}

	yield containerTag;
}

async function* handleTextNode(
	node: Node,
	config: any,
	runtimeState: any,
): AsyncGenerator<RenderableTreeNodes> {
	const result = await transform?.(node, config);
	runtimeState.context.methods.addToTextRegistry({
		text: text(result),
		scope: GLOBAL_SCOPE,
	});
	yield result;
}

async function* handleTag(
	node: Node,
	stateManager: StateManager,
): AsyncGenerator<RenderableTreeNodes> {
	const runtimeState = stateManager.getRuntimeState();
	const config = stateManager.getCurrentConfig(runtimeState.options.config);

	switch (node.tag) {
		case "loop": {
			yield* loop(node, config, stateManager);
			break;
		}
		case "ai": {
			yield* ai(node, config, stateManager);
			break;
		}
		case "set": {
			yield* set(node, config, stateManager);
			break;
		}
		case "if": {
			yield* if_(node, config, stateManager);
			break;
		}
		case "flow": {
			yield* flow(node, config, stateManager);
			break;
		}
		case "input": {
			yield* input(node, config, stateManager);
			break;
		}
		case "parallel": {
			yield* parallel(node, config, stateManager);
			break;
		}
		case "media": {
			yield* media(node, config, stateManager);
			break;
		}
		case "group": {
			yield* group(node, config, stateManager);
			break;
		}
		default: {
			// TODO: handle plugins
			const context = runtimeState.context;
			const plugins = context.plugins;

			if (!node.tag) {
				break;
			}

			const [pluginName, tagName] = node.tag.split("_");

			const plugin = plugins.get(pluginName);

			if (plugin?.tags && tagName && tagName in plugin.tags) {
				const tagConfig = plugin.tags[tagName];
				if ("execute" in tagConfig) {
					plugin.hooks?.beforeExecution?.(context);
					const result = yield* tagConfig.execute({
						node,
						config,
						state: runtimeState,
					});
					plugin.hooks?.afterExecution?.(context, result);
				}
			}
			break;
		}
	}
}

export async function* process({ node, stateManager }: AIMRuntime) {
	const signal = stateManager.getRuntimeState().options.signals.abort;

	for (const child of node.children) {
		if (signal.aborted) {
			throw new Error("Operation aborted");
		}

		for await (const result of walk(child, stateManager)) {
			yield result;
		}
	}
}



================================================
File: runtime/state.ts
================================================
import type { Config, ConfigFunction } from "@markdoc/markdoc";
import { BehaviorSubject, Subject } from "rxjs";
import { scan, shareReplay } from "rxjs/operators";
import type {
	AIMAdapter,
	AIMConfig,
	AIMPlugin,
	RuntimeContext,
	RuntimeMethods,
	RuntimeOptions,
	RuntimeState,
	StackFrame,
	StateBlock
} from "types";
import { getAllEnvVars } from "./envs";

// Create a StateManager class to handle isolated state
export class StateManager {
	private stateChain$ = new BehaviorSubject<StateBlock[]>([]);
	private runtimeContext$ = new BehaviorSubject<RuntimeContext>(null!);
	private runtimeState$ = new BehaviorSubject<RuntimeState>(null!);
	private stateUpdates$ = new Subject<{
		action: string;
		state: RuntimeContext;
	}>();
	private secrets$ = new BehaviorSubject<Record<string, string>>({});

	// Add public accessor for runtimeState$
	public get $runtimeState() {
		return this.runtimeState$;
	}

	constructor(
		initialConfig: AIMConfig,
		public runtimeOptions: RuntimeOptions,
	) {
		// Initialize runtime context
		const initialContext: RuntimeContext = {
			stack: [],
			data: {},
			plugins: new Map(),
			adapters: new Map(),
			config: initialConfig,
			textRegistry: {},
		};

		this.runtimeContext$.next(initialContext);

		// Initialize runtime state with runtimeOptions
		const initialState: RuntimeState = {
			options: {
				...runtimeOptions,
				config: initialConfig,
				settings: {
					...runtimeOptions.settings,
					useScoping: runtimeOptions.settings?.useScoping ?? true,
				},
			},
			context: {
				...initialContext,
				methods: this.createRuntimeMethods(),
			},
		};

		this.runtimeState$.next(initialState);

		// Setup state chain updates
		this.stateUpdates$
			.pipe(
				scan(
					(
						chain: StateBlock[],
						update: { state: RuntimeContext; action: string },
					) => {
						const prevState = chain[chain.length - 1]?.state || initialContext;
						const newBlock = this.createStateBlock(
							prevState,
							update.state,
							update.action,
						);
						return [...chain, newBlock];
					},
					[],
				),
				shareReplay(1),
			)
			.subscribe(this.stateChain$);

		// Initialize secrets from environment variables
		const envVars = getAllEnvVars();
		const secrets: Record<string, string> = {};
		for (const [key, value] of Object.entries(envVars)) {
			secrets[key] = value;
		}
		this.secrets$.next(secrets);
	}

	private createRuntimeMethods(): RuntimeMethods {
		return {
			pushStack: async (frame: StackFrame) => this.pushStack(frame),
			popStack: async ({ scope }: { scope: string }) => this.popStack(scope),
			setData: async ({
				data,
				scope,
			}: { data: Record<string, any>; scope: string }) =>
				this.setData(data, scope),
			resetContext: async () => this.resetContext(),
			addToTextRegistry: async ({
				text,
				scope,
			}: { text: string; scope: string }) =>
				this.addToTextRegistry(text, scope),
			clearTextRegistry: async ({ scope }: { scope: string }) =>
				this.clearTextRegistry(scope),
			getCurrentConfig: async (config: Config) => this.getCurrentConfig(config),
			getRuntimeContext: async () => this.getRuntimeContext(),
		};
	}

	// Secret management methods
	setSecret(key: string, value: string) {
		const currentSecrets = this.secrets$.value;
		this.secrets$.next({
			...currentSecrets,
			[key]: value,
		});
	}

	getSecret(key: string): string | undefined {
		return this.secrets$.value[key];
	}

	setSecrets(secrets: Record<string, string>) {
		this.secrets$.next({
			...this.secrets$.value,
			...secrets,
		});
	}

	getAllSecrets(): Record<string, string> {
		return { ...this.secrets$.value };
	}

	deleteSecret(key: string) {
		const currentSecrets = this.secrets$.value;
		const { [key]: _, ...remainingSecrets } = currentSecrets;
		this.secrets$.next(remainingSecrets);
	}

	clearSecrets() {
		this.secrets$.next({});
	}

	pushStack(frame: StackFrame) {
		const currentContext = this.runtimeContext$.value;
		const existingFrameIndex = currentContext.stack.findIndex(
			(f: { id: string; scope: string }) =>
				f.id === frame.id && f.scope === frame.scope,
		);

		const newStack = [...currentContext.stack];
		if (existingFrameIndex !== -1) {
			newStack[existingFrameIndex] = {
				...newStack[existingFrameIndex],
				variables: {
					...newStack[existingFrameIndex].variables,
					...frame.variables,
				},
			};
		} else {
			newStack.push(frame);
		}

		this.updateContext({ ...currentContext, stack: newStack }, "pushStack");
	}

	popStack(scope: string) {
		const currentContext = this.runtimeContext$.value;
		const newStack = currentContext.stack.filter(
			(frame: { scope: string }) => frame.scope !== scope,
		);
		this.updateContext({ ...currentContext, stack: newStack }, "popStack");
	}

	setData(data: Record<string, any>, scope: string) {
		const currentContext = this.runtimeContext$.value;
		const newData = {
			...currentContext.data,
			[scope]: {
				...(currentContext.data[scope] || {}),
				...data,
			},
		};
		this.updateContext({ ...currentContext, data: newData }, "setData");
	}

	resetContext() {
		const newContext: RuntimeContext = {
			stack: [],
			data: {},
			plugins: new Map(),
			adapters: new Map(),
			config: this.runtimeContext$.value.config,
			textRegistry: {},
		};
		this.updateContext(newContext, "resetContext");
	}

	addToTextRegistry(text: string, scope: string) {
		const currentContext = this.runtimeContext$.value;
		const newRegistry = {
			...currentContext.textRegistry,
			[scope]: [...(currentContext.textRegistry[scope] || []), text],
		};
		this.updateContext(
			{ ...currentContext, textRegistry: newRegistry },
			"addToTextRegistry",
		);
	}

	clearTextRegistry(scope: string) {
		const currentContext = this.runtimeContext$.value;
		const newRegistry = { ...currentContext.textRegistry };
		delete newRegistry[scope];
		this.updateContext(
			{ ...currentContext, textRegistry: newRegistry },
			"clearTextRegistry",
		);
	}

	registerPlugin(plugin: AIMPlugin, options?: unknown) {
		this.validatePlugin(plugin);
		const currentContext = this.runtimeContext$.value;

		if (plugin.init) {
			plugin.init(currentContext.config, options);
		}

		const newPlugins = new Map(currentContext.plugins);
		newPlugins.set(plugin.name, plugin);
		const newConfig = this.mergePluginConfig(plugin, currentContext.config);

		this.updateContext(
			{
				...currentContext,
				plugins: newPlugins,
				config: newConfig,
			},
			"registerPlugin",
		);
	}

	getPlugin(name: string): AIMPlugin | undefined {
		return this.runtimeContext$.value.plugins.get(name);
	}

	registerAdapter(adapter: AIMAdapter) {
		const currentContext = this.runtimeContext$.value;
		if (currentContext.adapters.has(adapter.type)) {
			return; // Adapter already registered, do nothing
		}

		if (adapter.init) {
			adapter.init();
		}

		const newAdapters = new Map(currentContext.adapters);
		newAdapters.set(adapter.type, adapter);

		this.updateContext(
			{
				...currentContext,
				adapters: newAdapters,
			},
			"registerAdapter",
		);
	}

	getAdapter(type: string): AIMAdapter | undefined {
		return this.runtimeContext$.value.adapters.get(type);
	}

	private validatePlugin(plugin: AIMPlugin) {
		const currentContext = this.runtimeContext$.value;
		if (currentContext.plugins.has(plugin.name)) {
			return; // Already registered, do nothing
		}

		if (plugin.dependencies?.plugins) {
			for (const dep of plugin.dependencies.plugins) {
				if (!currentContext.plugins.get(dep.name)) {
					throw new Error(
						`Plugin ${plugin.name} requires ${dep.name}, but it's not registered`,
					);
				}
			}
		}

		if (plugin.dependencies?.adapters) {
			for (const dep of plugin.dependencies.adapters) {
				if (!currentContext.adapters.get(dep.name)) {
					throw new Error(
						`Plugin ${plugin.name} requires adapter ${dep.name}, but it's not registered`,
					);
				}
			}
		}
	}

	private mergePluginConfig(
		plugin: AIMPlugin,
		currentConfig: AIMConfig,
	): AIMConfig {
		const newConfig = { ...currentConfig };

		if (plugin.tags) {
			newConfig.tags = { ...newConfig.tags, ...plugin.tags };
		}

		if (plugin.functions) {
			const pluginFunctions = Object.fromEntries(
				Object.entries(plugin.functions).map(([key, fn]) => [
					key,
					typeof fn === "function" ? { execute: fn } : fn,
				]),
			) as Record<string, ConfigFunction>;
			newConfig.functions = { ...newConfig.functions, ...pluginFunctions };
		}

		return newConfig;
	}

	private createStateBlock(
		prevState: RuntimeContext,
		newState: RuntimeContext,
		action: string,
	): StateBlock {
		return {
			timestamp: Date.now(),
			action,
			hash: crypto.randomUUID(),
			previousHash: this.stateChain$.value.at(-1)?.hash || "genesis",
			state: newState,
			diff: {
				stack: newState.stack.length - prevState.stack.length,
				textRegistry:
					Object.keys(newState.textRegistry).length -
					Object.keys(prevState.textRegistry).length,
				data:
					Object.keys(newState.data).length -
					Object.keys(prevState.data).length,
			},
		};
	}

	private updateContext(newContext: RuntimeContext, action: string) {
		this.runtimeContext$.next(newContext);
		this.stateUpdates$.next({ action, state: newContext });

		this.runtimeState$.next({
			...this.runtimeState$.value,
			context: {
				...newContext,
				methods: this.createRuntimeMethods(),
			},
		});
	}

	getScopedVariables(scope: string): Record<string, any> {
		return this.runtimeContext$.value.data[scope] || {};
	}

	getScopedText(scope: string): string[] {
		return this.runtimeContext$.value.textRegistry[scope] || [];
	}

	clearScope(scope: string) {
		this.setData({}, scope);
	}

	processScopedVariables(): Record<string, any> {
		const currentContext = this.runtimeContext$.value;
		const scopedVariables: Record<string, Record<string, any>> = {};

		for (const frame of currentContext.stack) {
			if (!scopedVariables[frame.scope]) {
				scopedVariables[frame.scope] = {};
			}

			scopedVariables[frame.scope][frame.id] = {
				...scopedVariables[frame.scope][frame.id],
				...frame.variables,
			};
		}

		const stackVariables: Record<string, any> = {};
		Object.values(scopedVariables).forEach((scopeVars) => {
			Object.assign(stackVariables, scopeVars);
		});

		return stackVariables;
	}

	getCurrentConfig(config: Config): Config {
		const currentConfig = this.runtimeState$.value.options.config;
		const stackVariables = this.processScopedVariables();
		return {
			...config,
			...currentConfig,
			variables: {
				...config.variables,
				...currentConfig.variables,
				...stackVariables,
			},
		};
	}

	getRuntimeState(): RuntimeState {
		return this.runtimeState$.value;
	}

	getRuntimeContext(): RuntimeContext {
		return this.runtimeContext$.value;
	}

	getStateHistory(): StateBlock[] {
		return this.stateChain$.value;
	}

	getStateAtBlock(hash: string): RuntimeContext | undefined {
		return this.stateChain$.value.find((b: { hash: string }) => b.hash === hash)
			?.state;
	}
}

// Export a factory function to create new state managers
export function createStateManager(
	initialConfig: AIMConfig,
	options: RuntimeOptions,
): StateManager {
	return new StateManager(initialConfig, options);
}



================================================
File: runtime/tools/converter.ts
================================================
import { tool, type CoreTool, type ToolExecutionOptions } from 'ai';
import { StructuredTool } from 'langchain/tools';
import type { AIMTool } from 'types';
import { z } from 'zod';

// TODO: need to improve support for LangChain tools. And remove CoreTool to support all existing tool types.

/**
 * Converts any supported tool type to Vercel AI SDK format
 * @param inputTool The tool to convert (LangChain, AIM, or Vercel AI SDK tool)
 * @returns Vercel AI SDK compatible tool
 */
export function convertToAISDKTool(
    inputTool: StructuredTool | AIMTool | CoreTool
): CoreTool {
    // If it's already a CoreTool, return as-is
    if ('description' in inputTool && 'parameters' in inputTool && 'execute' in inputTool) {
        return inputTool as CoreTool;
    }

    // Handle LangChain tool
    if (inputTool instanceof StructuredTool) {
        const schema = inputTool.schema;
        return tool({
            description: inputTool.description,
            parameters: schema || z.object({
                input: z.string().describe(inputTool.description)
            }),
            execute: async (args: { [key: string]: any }, options: ToolExecutionOptions) => {
                const result = await inputTool.invoke(args);
                return { result };
            }
        });
    }

    // Handle AIM tool
    if ('description' in inputTool && 'parameters' in inputTool && 'execute' in inputTool) {
        const aimTool = inputTool as AIMTool;
        return tool({
            description: aimTool.description,
            parameters: aimTool.parameters,
            execute: async (args: unknown, options: ToolExecutionOptions) => {
                if (!aimTool.execute) {
                    throw new Error('AIM tool is missing execute method');
                }
                const result = await aimTool.execute(args);
                return { result };
            }
        });
    }

    throw new Error('Unsupported tool type');
}


================================================
File: test/test-logs/index.ts
================================================
import { writeFileSync } from "fs";
import { transform } from "markdoc/transform";
import { aim, defaultRuntimeOptions, renderers, Tag } from "../../index";
import { html } from "../../markdoc/renderers/html";
import { z } from "zod";

// Sample test content
const content = {
	main: `
{% loop #loop count=2 %}
    {% if equals($loop.index, 1) %}
        What is the number the first time? {% $loop.index %}
    {% else /%}
        What is the number the second time? {% $loop.index %}
    {% /if %}
{% /loop %}
`,
	secondary: `
# Hey

hey

`,
	calculator: `---
title: Loop
description: Use loops to repeat a block of code multiple times.
input:
    - name: count
      type: number
      description: The number of times to repeat the block
---

Let's do the {% $frontmatter.input.count %} times table. Output just the next number.

{% loop #loop count=$frontmatter.input.count %}

    {% $loop.index %} x {% $frontmatter.input.count %} = {% ai model="openai/gpt-4o-mini" /%}

{% /loop %}
`,
	test: `---
title: Loop
description: Use loops to repeat a block of code multiple times.
input:
    - name: count
      type: number
      description: The number of times to repeat the block
---

Let's do the {% $frontmatter.input.count %} times table. 

Output just the next number.

{% loop #loop count=$frontmatter.input.count %}

  {% add($loop.index, 1) %} x {% $frontmatter.input.count %} = {% ai #result model="openai/gpt-4o-mini" /%}

{% /loop %}

Yay, we're done!`,
	signEthTransaction: `

Lets sign the transaction. {% sign-eth-transaction /%}

What is the signed transaction?

{% ai model="openai/gpt-4o-mini" /%}

{% if equals(1, 1) %}   

{% loop #loop count=2 %}

This is the loop index: {% $loop.index %}

{% /loop %}

{% else /%}

{% ai model="openai/gpt-4o-mini" /%}

{% /if %}

`,

	headsTails: `---
title: "Heads or Tails "
description: "A coin flip game with conditional responses"
---

We just tossed a coin, was it heads or tails?

The last tosses were heads, heads, tails, heads, tails, heads, heads, heads.

Output 'heads' or 'tails' only. Output heads 

{% ai #flip model="openai/gpt-4o-mini" /%}

<!-- We reference the value of the flip in this if-else block -->

{% if equals($flip.result, "heads") %}

    Heads, I win!

    Should I gloat? Write "yes" or "no" only.

    {% ai #gloat model="openai/gpt-4o-mini" /%}

    GLOAT {% $gloat.result %}

<!-- It's possible to nest container blocks inside other container blocks. In fact you can put all the same things in the body of a container block as you can in a prompt -->

        {% if equals($gloat.result, "yes") %}

            Now, write a gloating song. Output just the song.

            {% ai #song model="openai/gpt-4o-mini" /%}

        {% /if %}

        {% else /%}

            Now, be humble and congratulate the loser on their well played match.

            {% ai #humble model="openai/gpt-4o-mini" /%}

        {% /if %}

        {% if equals($flip.result, "tails") %}

            Tails, you lose! 

        {% /if %}

    {% else /%}

    Neither heads nor tails, everyone loses 

{% /if %}

{% $flip.result %}
`,
	ifElse: `---
title: "If else"
description: "An example of how to use AIM to create a document."
input:
  - name: topic
    type: string
    description: "The topic to write about"
  - name: type
    type: string
    description: "The type of writing to create"
  - name: tone
    type: string
    description: "The emotional tone to use"
---

Write a {% $frontmatter.input.type %} about {% $frontmatter.input.topic %}

{% if equals($frontmatter.input.tone, "happy") %}
Make it full of joy and happiness. 

{% else equals($frontmatter.input.tone, "sad") /%}

generate a sad prompt

{% ai #sad-prompt model="openai/gpt-4o-mini" /%}

{% $sad-prompt.result %}

{% else equals($frontmatter.input.tone, "silly") /%}
Make it full of sadness and despair. 

{% else /%}

It should have the following tone: {% $frontmatter.input.tone %}

{% /if %}

{% ai #output model="openai/gpt-4o-mini" /%}
`,
	loopUntil: `

Output a random number between 1 and 100. Output just the number.

{% loop lessThanOrEqual($value.result, 30) #loop %}

    {% ai #value model="openai/gpt-4o" /%}
    
{% /loop %}

Yay, we're done! The number is {% $value.result %} and it took {% $loop.index %} tries.
`,
	greeting: `


\`\`\`js {% #example %} 
// The code execution node will execute the given JavaScript code

// For example we can write functions ...
function addNumbers(n1, n2) {
  return n1 + n2;
}

// ... call those functions ...
const sum = addNumbers(1, 1);

// ... log outputs ...
console.log("1 + 1 =", sum);

// ... and even mention values from outside the code
const greeting = \`Hello \${aimVariables.frontmatter.input.name}, you're looking good today \`;

// If we return a value it'll be included in the prompt
return greeting;
\`\`\`

The code returned: {% $example.result %}

`,
	mathsQuestion: `---
title: "Calculator "
description: "Using code blocks to solve math problems"
input:
  - name: maths_question
    type: string
    description: "The math question to solve"
---

Here's a maths question:

{% $frontmatter.input.maths_question %}

Write a JavaScript function that returns the result of this question. Do not log anything. Output just the code and a call to the function.

{% ai #generated_code model="openai/gpt-4o" /%}

\`\`\`js {% #eval %}
// We pass code that was generated as a string into \`eval\` which will execute it 
// First we remove any backticks/wrappers around the code
const code = aimVariables.generated_code.result.replaceAll(/\`\`\`javascript/g, "").replaceAll(/\`\`\`js/g, "").replaceAll(/\`\`\`JavaScript/g, "").replaceAll(/\`\`\`JS/g, "").replaceAll(/\`\`\`/g, "");

console.log(code);
return eval(code);
\`\`\`

The answer is: {% $eval.result %}
`,
	wikipediaResults: `---
title: "Q&A with Wikipedia "
description: "Using code blocks to query Wikipedia"
input:
  - name: question
    type: string
    description: "The question to answer"
---

<!-- The code block is connected to the web so it can be used to hit external APIs too. This can be very useful in a number of ways. Here we show how it can be used to query for up-to-date information from Wikipedia. -->

Retrieval assisted (RAG) question answering using Wikipedia.
e.g. Try asking "When did OceanGate sink?", "How tall is the tallest penguin species?"

Question: {% $frontmatter.input.question %}

<!-- First we get the language model to generate a search term -->

Let's search Wikipedia to answer this question. What's the best search term to use? Output just the search term.

{% ai #search_term model="openai/gpt-4o-mini" /%}

<!-- This chunk of code will hit Wikipedia's API and extract the top 3 articles -->


\`\`\`js {% #wikipedia_results %}

// Read the term generated by the language model
let input;
try {
    input = aimVariables.search_term.result.trim().replace(/^"+|"+$/g, '');
} catch (error) {
    console.error("Error reading search term:", error);
    return { result: "", error: error.toString() };
}

console.log("Searching for the term", input);

try {
    const maxResults = 3;
    const searchTerm = encodeURIComponent(input.trim());
    const url = \`https://en.wikipedia.org/w/api.php?format=json&action=query&list=search&srsearch=\${searchTerm}&srlimit=\${maxResults}&utf8=&origin=*\`;
    const response = await fetch(url);
    const data = await response.json();

    const fetchExtract = async (title) => {
        console.log("Retrieving", title);
        const extractUrl = \`https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&titles=\${encodeURIComponent(title)}&redirects=1&origin=*\`;
        const extractResponse = await fetch(extractUrl);
        const extractData = await extractResponse.json();
        const pageId = Object.keys(extractData.query.pages)[0];
        const extract = extractData.query.pages[pageId].extract;
        return [title, extract];
    }

    try {
        if (data.query.search.length > 0) {
            console.log("Got some results extracting top", data.query.search.length);
            const extracts = await Promise.all(data.query.search.map(result => fetchExtract(result.title)));
            return { result: extracts, error: null };
        } else {
            return { result: "No results found.", error: null };
        }
    } catch (error) {
        console.error("Error extracting Wikipedia results:", error);
        return { result: "", error: error.toString() };
    }
} catch (error) {
    console.error("Error processing Wikipedia results:", error);
    return { result: "", error: error.toString() };
}
    
\`\`\`
<!-- The code returns the top 3 Wikipedia articles that match the search term -->

## Answer:

Based on the information above give the most helpful answer to the question.

Question: {% $frontmatter.input.question %}

Results: {% debug($wikipedia_results) %}

{% ai #answer model="openai/gpt-4o-mini" /%}

{% $answer.result %}
`,
	loop: `

{% loop #loop count=2 %}

This is the loop index: {% $loop.index %}

{% /loop %}
`,
	parallel: `

{% parallel #parallel %}

    {% group #group %}

        {% loop #loop1 count=100 %}

            This is the loop index: {% $loop1.index %}

        {% /loop %}

        {% loop #loop2 count=100 %}

            This is the loop index: {% $loop2.index %}

        {% /loop %}

    {% /group %}
    {% group #group %}

        {% loop #loop1 count=100 %}

            This is the loop index: {% $loop1.index %}

        {% /loop %}

        {% loop #loop2 count=100 %}

            This is the loop index: {% $loop2.index %}

        {% /loop %}

    {% /group %}

{% /parallel %}
`,
	structuredOutputs: `

Create a recipe for chocholate cake

{% ai #output1 model="openai/gpt-4o-mini" structuredOutputs={recipe: "string", ingredients: "string[]", instructions: "string[]"} /%}

# {% $output1.structuredOutputs.recipe %}

## Ingredients:

{% loop #loop1 items=$output1.structuredOutputs.ingredients %}

# {% $loop1.count %}. {% $loop1.item %}

{% /loop %}

`,
	timesTable: `---
title: Loop
description: Use loops to repeat a block of code multiple times.
input:
    - name: count
      type: number
      description: The number of times to repeat the block
---

Let's do the {% $frontmatter.input.count %} times table. 

Output just the next number.

{% loop #loop count=$frontmatter.input.count %}

  {% add($loop.index, 1) %} x {% $frontmatter.input.count %} = {% ai #result model="openai/gpt-4o-mini" /%}

{% /loop %}

The next number is {% ai #result model="openai/gpt-4o-mini" /%}

Yay, we're done!
`,
	openrouter: `
    How is the weather today in lisbon?


    {% ai  
    model="openai/gpt-4o-mini:online@openrouter" 
    structuredOutputs={
        "weather": {
            "type": "object",
            "properties": {
                "temperature": { "type": "number" },
                "description": { "type": "string" }
            }
        }
} /%}
`,
	useTool: `

    Use tool hello and translate to portuguese

    {% ai #hello model="openai/gpt-4o-mini" structuredOutputs="{greeting: string}"/%}

    {% $hello.structuredOutputs.greeting %}
    `,
	flow: `

    I would like to talk about flowers in amazonia
    
    {% flow #flow path="/test-flow.md" /%}

    I would like to talk about cars in the future

    {% flow #flow path="/test-flow.md" /%}
    `,
};

// Create HTML template
const htmlTemplate = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIM Runtime State Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsoneditor/9.10.2/jsoneditor.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/jsoneditor/9.10.2/jsoneditor.min.css" rel="stylesheet" type="text/css">
    <style>
        /* Base styles */
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Tab styles */
        .tab-btn.active-tab {
            position: relative;
        }
        .tab-btn.active-tab::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: rgb(59, 130, 246);
            transition: all 0.3s ease;
        }

        /* Typography */
        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: rgb(30, 41, 59);
            padding: 1rem 0;
            margin: 1rem 0;
            line-height: 1.2;
        }

        p {
            padding: 0.75rem 0;
            margin: 0.5rem 0;
            color: #1f2937;
            line-height: 1.6;
            font-size: 1.125rem;
        }

        /* Component styles */
        loop {
            display: block;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border: 2px solid #e5e7eb;
            border-radius: 0.75rem;
            background-color: #f8fafc;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            position: relative;
        }

        loop::before {
            content: 'Loop';
            position: absolute;
            top: -12px;
            left: 16px;
            background: #fff;
            padding: 0 8px;
            color: #6b7280;
            font-size: 0.875rem;
            font-weight: 500;
        }

        ai {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            margin: 0 0.25rem;
            background-color: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 0.375rem;
            color: #0369a1;
            font-family: monospace;
        }

        inline {
            display: block;
            padding: 0.5rem;
            line-height: 1.6;
            color: #374151;
            font-size: 1.1rem;
        }

        paragraph {
            display: block;
            margin: 1rem 0;
            padding: 0.5rem;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        /* Times table specific styles */
        loop paragraph:nth-child(even) {
            background-color: #f8fafc;
        }

        loop paragraph inline {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'Courier New', monospace;
        }

        loop ai {
            font-weight: 600;
            min-width: 3rem;
            text-align: right;
        }

        paragraph:last-of-type inline {
            color: #059669;
            font-weight: 500;
        }

        /* JSON Editor styles */
        .jsoneditor {
            border: 2px solid #e5e7eb !important;
            border-radius: 0.75rem !important;
        }

        .jsoneditor-menu {
            background-color: #f8fafc !important;
            border-bottom: 2px solid #e5e7eb !important;
            border-top-left-radius: 0.75rem !important;
            border-top-right-radius: 0.75rem !important;
        }

        .jsoneditor-navigation-bar {
            border-bottom: 2px solid #e5e7eb !important;
        }

        /* Additional components */
        code {
            font-family: 'Courier New', monospace;
            background-color: #f1f5f9;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.875em;
        }

        pre {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 1rem 0;
        }

        button {
            background-color: #3b82f6;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #2563eb;
        }

        /* Data visualization */
        .data-container {
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 1rem;
            margin: 1rem 0;
        }

        .data-header {
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.5rem;
        }

        .data-content {
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="max-w-7xl mx-auto p-6">        
        <div class="bg-white shadow-sm rounded-lg">
            <div class="border-b border-gray-200">
                <nav class="flex" aria-label="Tabs">
                    <button class="tab-btn active-tab w-1/3 py-4 px-1 text-center border-b-2 font-medium text-sm transition-all duration-200" id="state-tab">
                        State Chain
                    </button>
                    <button class="tab-btn w-1/3 py-4 px-1 text-center border-b-2 font-medium text-sm transition-all duration-200" id="data-tab">
                        Events Log
                    </button>
                    <button class="tab-btn w-1/3 py-4 px-1 text-center border-b-2 font-medium text-sm transition-all duration-200" id="output-tab">
                        Output
                    </button>
                    <button class="tab-btn w-1/3 py-4 px-1 text-center border-b-2 font-medium text-sm transition-all duration-200" id="ast-tab">
                        AST
                    </button>
                    <button class="tab-btn w-1/3 py-4 px-1 text-center border-b-2 font-medium text-sm transition-all duration-200" id="content-tab">
                        Raw Content
                    </button>
                    <button class="tab-btn w-1/3 py-4 px-1 text-center border-b-2 font-medium text-sm transition-all duration-200" id="html-content-tab">
                        HTML Content
                    </button>
                </nav>
            </div>

            <div class="p-6">
                <div id="state-logs" class="tab-content space-y-6"></div>
                <div id="data-logs" class="tab-content hidden space-y-6"></div>
                <div id="ast-logs" class="tab-content hidden space-y-6"></div>
                <div id="output-logs" class="tab-content hidden space-y-6"></div>
                <div id="content-logs" class="tab-content hidden space-y-6"></div>
                <div id="html-content-logs" class="tab-content hidden space-y-6"></div>
            </div>
        </div>
    </div>

    <script>
        const logs = LOGS_PLACEHOLDER;
        const dataEvents = DATA_EVENTS_PLACEHOLDER;
        const output = OUTPUT_PLACEHOLDER;
        const ast = AST_PLACEHOLDER;
        const rawContent = CONTENT_PLACEHOLDER;
        const htmlContent = HTML_CONTENT_PLACEHOLDER;

        function formatTimestamp(ts) {
            return new Date(ts).toLocaleTimeString('en-US', { 
                hour12: true,
                hour: 'numeric',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            });
        }

        function renderDiff(value) {
            if (value === 0) return '<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-600">0</span>';
            const className = value > 0 
                ? 'bg-green-100 text-green-800' 
                : 'bg-red-100 text-red-800';
            const prefix = value > 0 ? '+' : '';
            return \`<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium \${className}">\${prefix}\${value}</span>\`;
        }

        function renderLogEntry(log, index) {
            return \`
                <div class="bg-white rounded-lg shadow-md p-6 fade-in hover:shadow-lg transition-shadow duration-200">
                    <div class="flex items-center justify-between mb-4">
                        <div class="text-gray-500 text-sm font-mono">\${formatTimestamp(log.timestamp)}</div>
                        <div class="text-blue-600 font-semibold px-3 py-1 bg-blue-50 rounded-full">\${log.action}</div>
                    </div>
                    <div class="font-mono text-sm text-gray-600 mb-4 bg-gray-50 p-3 rounded-lg">
                        <div>Hash: <span class="text-blue-600">\${log.hash}</span></div>
                        <div>Previous: <span class="text-purple-600">\${log.previousHash}</span></div>
                    </div>
                    <div class="grid grid-cols-3 gap-4 mb-4">
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="text-sm font-medium text-gray-700 mb-1">Stack</div>
                            \${renderDiff(log.diff.stack)}
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="text-sm font-medium text-gray-700 mb-1">Text Registry</div>
                            \${renderDiff(log.diff.textRegistry)}
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <div class="text-sm font-medium text-gray-700 mb-1">Data</div>
                            \${renderDiff(log.diff.data)}
                        </div>
                    </div>
                    <div class="relative">
                        <button onclick="toggleState(this)" class="text-sm text-blue-600 hover:text-blue-800 mb-2">Show State</button>
                        <div id="jsoneditor-\${index}" style="height: 400px; display: none;"></div>
                    </div>
                </div>
            \`;
        }

        function renderDataEvent(event) {
            const typeColors = {
                start: 'bg-blue-50 text-blue-600',
                finish: 'bg-purple-50 text-purple-600',
                success: 'bg-green-50 text-green-600',
                error: 'bg-red-50 text-red-600',
                log: 'bg-gray-50 text-gray-600',
                data: 'bg-yellow-50 text-yellow-600'
            };

            const levelColors = {
                info: 'text-blue-500',
                success: 'text-green-500',
                error: 'text-red-500',
                debug: 'text-gray-500'
            };

            return \`
                <div class="bg-white rounded-lg shadow-md p-6 fade-in hover:shadow-lg transition-shadow duration-200">
                    <div class="flex items-center justify-between mb-4">
                        <div class="text-gray-500 text-sm font-mono">\${formatTimestamp(event.timestamp)}</div>
                        <div class="font-semibold px-3 py-1 rounded-full \${typeColors[event.type] || 'bg-gray-50 text-gray-600'}">\${event.type}</div>
                    </div>
                    <div class="flex items-center gap-2 mb-4">
                        <div class="text-sm \${levelColors[event.level] || 'text-gray-500'}">\${event.level}</div>
                        <div class="text-sm text-gray-700">\${event.message || ''}</div>
                    </div>
                    \${event.stack ? \`
                        <div class="mb-4">
                            <div class="text-sm font-medium text-red-600 mb-2">Stack Trace:</div>
                            <pre class="bg-red-50 p-4 rounded-lg overflow-x-auto text-sm text-red-700">\${event.stack}</pre>
                        </div>
                    \` : ''}
                    \${event.data ? \`
                        <div>
                            <div class="text-sm font-medium text-gray-700 mb-2">Data (\${event.dataType || 'unknown type'}):</div>
                            <pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto text-sm">\${JSON.stringify(event.data, null, 2)}</pre>
                        </div>
                    \` : ''}
                </div>
            \`;
        }

        function renderAST(ast) {
            return \`
                <div class="bg-white rounded-lg shadow-md p-6 fade-in hover:shadow-lg transition-shadow duration-200">
                    <div class="flex items-center justify-between mb-4">
                        <div class="font-semibold px-3 py-1 rounded-full bg-blue-50 text-blue-600">AST</div>
                    </div>
                    <div id="ast-editor" style="height: 600px;"></div>
                </div>
            \`;
        }

        function renderContent(content) {
            return \`
                <div class="bg-white rounded-lg shadow-md p-6 fade-in hover:shadow-lg transition-shadow duration-200">
                    <div class="flex items-center justify-between mb-4">
                        <div class="font-semibold px-3 py-1 rounded-full bg-blue-50 text-blue-600">Raw Content</div>
                    </div>
                    <pre class="bg-gray-50 p-4 rounded-lg overflow-x-auto text-sm">\${content}</pre>
                </div>
            \`;
        }

        function renderHtmlContent(content) {
            return \`
                <div class="bg-white rounded-lg shadow-md p-6 fade-in hover:shadow-lg transition-shadow duration-200">
                    <div class="flex items-center justify-between mb-4">
                        <div class="font-semibold px-3 py-1 rounded-full bg-blue-50 text-blue-600">HTML Content</div>
                    </div>
                    \${content}
                </div>
            \`;
        }

        function toggleState(button) {
            const editorContainer = button.nextElementSibling;
            const isHidden = editorContainer.style.display === 'none';
            editorContainer.style.display = isHidden ? 'block' : 'none';
            button.textContent = isHidden ? 'Hide State' : 'Show State';
        }

        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('border-blue-500', 'text-blue-600', 'active-tab');
                btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
            });
            
            document.getElementById(\`\${tabName}-logs\`).classList.remove('hidden');
            const activeTab = document.getElementById(\`\${tabName}-tab\`);
            activeTab.classList.add('border-blue-500', 'text-blue-600', 'active-tab');
            activeTab.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');

            // Update URL with tab parameter
            const url = new URL(window.location);
            url.searchParams.set('tab', tabName);
            window.history.pushState({}, '', url);
        }

        // Add click handlers to tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
            const tabName = btn.id.replace('-tab', '');
            btn.addEventListener('click', () => showTab(tabName));
        });

        // Initialize editors after DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize state logs
            document.getElementById('state-logs').innerHTML = logs.map(renderLogEntry).join('');
            logs.forEach((log, index) => {
                const container = document.getElementById(\`jsoneditor-\${index}\`);
                if (container) {
                    const editor = new JSONEditor(container, {
                        mode: 'view',
                        modes: ['view', 'form', 'code', 'tree'],
                        navigationBar: false
                    });
                    editor.set(log.state);
                }
            });

            // Initialize data logs
            document.getElementById('data-logs').innerHTML = dataEvents.map(renderDataEvent).join('');
            
            // Initialize output logs
            document.getElementById('output-logs').innerHTML = output;
            
            // Initialize AST view
            document.getElementById('ast-logs').innerHTML = renderAST(ast);
            const astEditor = new JSONEditor(document.getElementById('ast-editor'), {
                mode: 'view',
                modes: ['view', 'form', 'code', 'tree'],
                navigationBar: false
            });
            astEditor.set(ast);

            // Initialize content view
            document.getElementById('content-logs').innerHTML = renderContent(rawContent);
            document.getElementById('html-content-logs').innerHTML = renderHtmlContent(htmlContent);

            // Check URL for tab parameter
            const urlParams = new URLSearchParams(window.location.search);
            const activeTab = urlParams.get('tab') || 'state';
            showTab(activeTab);
        });
    </script>
</body>
</html>
`;

async function main() {
	const dataEvents: any[] = [];
	const abortController = new AbortController();

	// Initialize AIM document
	const doc = aim({
		content: run,
		options: {
			signals: {
				abort: abortController.signal,
			},
			experimental_files: {
				"/test-flow.md": {
					content: `---
                    input:
                      - name: topic
                        type: string
                        description: The topic of the flow
                    ---
                    Generate a sentence about the topic: {% $frontmatter.input.topic %}
                {% ai /%}
                make it crazier
                {% ai /%}
                make it funnier
                {% ai /%}
                    `,
				},
			},
			tools: {
				hello: {
					description: "This is a test tool",
					parameters: z.object({
						name: z.string(),
					}),
					execute: async (args: { name: string }) => {
						return `Hello, ${args.name}!`;
					},
				},
			},
			events: {
				onStart: (msg: string) => {
					console.log(" Started:", msg);
					dataEvents.push({
						type: "start",
						message: msg,
						timestamp: new Date().toISOString(),
						level: "info",
					});
				},
				onFinish: (msg: string) => {
					console.log(" Finished:", msg);
					dataEvents.push({
						type: "finish",
						message: msg,
						timestamp: new Date().toISOString(),
						level: "info",
					});
				},
				onSuccess: (msg: string) => {
					console.log(" Success:", msg);
					dataEvents.push({
						type: "success",
						message: msg,
						timestamp: new Date().toISOString(),
						level: "success",
					});
				},
				onError: (msg: string) => {
					console.error(" Error:", msg);
					dataEvents.push({
						type: "error",
						message: msg,
						timestamp: new Date().toISOString(),
						level: "error",
						stack: new Error().stack,
					});
				},
				onLog: (msg: string) => {
					console.log(" Log:", msg);
					dataEvents.push({
						type: "log",
						message: msg,
						timestamp: new Date().toISOString(),
						level: "debug",
					});
				},
				onData: (data: any) => {
					console.log(" Data:", data);
					dataEvents.push({
						type: "data",
						data,
						timestamp: new Date().toISOString(),
						level: "info",
						dataType: typeof data,
					});
				},
			},
			settings: {
				useScoping: false,
			},
			config: {},
			adapters: defaultRuntimeOptions.adapters || [],
			plugins: [
				{
					plugin: {
						name: "sign-eth-transaction",
						version: "0.0.1",
						tags: {
							"sign-eth-transaction": {
								render: "sign-eth-transaction",
								execute: async function* ({ node, config, state }) {
									const result =
										"Here's the signed transaction: 0x1234567890d3fsasd";
									state.context.methods.addToTextRegistry({
										text: result,
										scope: "global",
									});
									yield result;
									yield new Tag("div", { text: result });
								},
							},
						},
					},
				},
			],
		},
	});

	// Execute document
	// await doc.execute({
	//     input: {
	//         topic: "The future of AI",
	//         type: "sentence",
	//         tone: "sad",
	//         count: 10,
	//         name: "Micro",
	//         maths_question: "What is 1 + 1?",
	//         question: "What is the capital of France?"
	//     }
	// });

	//TEST ABORTION
	const shouldAbort = false;
	let resultCount = 0;
	for await (const result of doc.executeWithGenerator({
		input: {
			topic: "The future of AI",
			type: "sentence",
			tone: "sad",
			count: 10,
			name: "Micro",
			maths_question: "What is 1 + 1?",
			question: "What is the capital of France?",
		},
	})) {
		console.log(" Generator Result:", JSON.stringify(result, null, 2));
		resultCount++;
		if (resultCount >= 2 && shouldAbort) {
			console.log(" Aborting execution...");
			abortController.abort();
			break;
		}
	}

	// Get state chain logs
	const logs = doc.stateManager.getStateHistory();
	const AST = doc.ast;

	console.log(" Secrets:", doc.stateManager.getAllSecrets());

	console.log(" Data Events:", dataEvents);

	// Generate HTML with logs
	const htmlOutput = dataEvents
		.filter((event) => event.type === "data")
		.map((event) => html(event.data))
		.join("");

	console.log(" HTML Output:", htmlOutput);

	const renderableContent = await transform(
		doc.ast,
		defaultRuntimeOptions.config,
	);

	const finalHtml = htmlTemplate
		.replace("LOGS_PLACEHOLDER", JSON.stringify(logs, null, 2))
		.replace("DATA_EVENTS_PLACEHOLDER", JSON.stringify(dataEvents, null, 2))
		.replace("OUTPUT_PLACEHOLDER", JSON.stringify(htmlOutput, null, 2))
		.replace("AST_PLACEHOLDER", JSON.stringify(AST, null, 2))
		.replace("CONTENT_PLACEHOLDER", JSON.stringify(run, null, 2))
		.replace(
			"HTML_CONTENT_PLACEHOLDER",
			JSON.stringify(html([renderableContent])),
		);

	// Write to file
	writeFileSync("logs.html", finalHtml);

	console.log(" Logs have been written to logs.html");
	process.exit(0);
}

const run = content.greeting;

main().catch(console.error);



================================================
File: test/unit-tests/aim.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { aim } from "../../aim";

describe("aim", () => {
	test("initializes with default options", () => {
		const result = aim({
			content: "# Test",
			options: {
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signals: {
					abort: new AbortController().signal,
				},
				settings: {
					useScoping: false,
				},
				config: { variables: {} },
			},
		});

		expect(result.ast).toBeDefined();
		expect(result.frontmatter).toBeDefined();
		expect(result.errors).toEqual([]);
		expect(result.warnings).toEqual([]);
		expect(result.stateManager).toBeDefined();
		expect(result.execute).toBeDefined();
	});

	test("aborts execution when signal is triggered", async () => {
		const abortController = new AbortController();
		const result = aim({
			content: "{% ai %}test{% /ai %}", // Add AI tag that will take time to process
			options: {
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signals: {
					abort: abortController.signal,
				},
				settings: {
					useScoping: false,
				},
				config: { variables: {} },
			},
		});

		// Start execution
		const executePromise = result.execute();

		// Trigger abort signal
		abortController.abort();

		// Execution should reject with abort error
		expect(executePromise).rejects.toThrow("Execution aborted");
	});

	test("aborts nested processing when signal is triggered", async () => {
		const abortController = new AbortController();
		const result = aim({
			content: `
                {% parallel %}
                    {% ai %}test 1{% /ai %}
                    {% ai %}test 2{% /ai %}
                {% /parallel %}
            `,
			options: {
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signals: {
					abort: abortController.signal,
				},
				settings: {
					useScoping: false,
				},
				config: { variables: {} },
			},
		});

		const executePromise = result.execute();

		// Give a small delay then abort
		setTimeout(() => {
			abortController.abort();
		}, 100);

		expect(executePromise).rejects.toThrow("Execution aborted");
	});
});



================================================
File: test/unit-tests/state.test.ts
================================================
import { describe, test, expect } from "bun:test";
import { StateManager } from "../../runtime/state";
import { GLOBAL_SCOPE } from "../../aim";

describe("StateManager", () => {
	test("constructor initializes with correct default state", () => {
		const manager = new StateManager(
			{ variables: {} },
			{
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signal: new AbortController().signal,
				settings: {
					useScoping: true,
				},
				config: { variables: {} },
			},
		);

		const context = manager.getRuntimeContext();
		expect(context.stack).toEqual([]);
		expect(context.data).toEqual({});
		expect(context.plugins.size).toBe(0);
		expect(context.adapters.size).toBe(0);
		expect(context.textRegistry).toEqual({});
	});

	test("pushStack adds new frame correctly", () => {
		const manager = new StateManager(
			{ variables: {} },
			{
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signal: new AbortController().signal,
				settings: {
					useScoping: true,
				},
				config: { variables: {} },
			},
		);

		manager.pushStack({
			id: "test",
			variables: { foo: "bar" },
			scope: GLOBAL_SCOPE,
		});

		const context = manager.getRuntimeContext();
		expect(context.stack.length).toBe(1);
		expect(context.stack[0]).toEqual({
			id: "test",
			variables: { foo: "bar" },
			scope: GLOBAL_SCOPE,
		});
	});

	test("pushStack updates existing frame with same id and scope", () => {
		const manager = new StateManager(
			{ variables: {} },
			{
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signal: new AbortController().signal,
				settings: {
					useScoping: true,
				},
				config: { variables: {} },
			},
		);

		manager.pushStack({
			id: "test",
			variables: { foo: "bar" },
			scope: GLOBAL_SCOPE,
		});

		manager.pushStack({
			id: "test",
			variables: { baz: "qux" },
			scope: GLOBAL_SCOPE,
		});

		const context = manager.getRuntimeContext();
		expect(context.stack.length).toBe(1);
		expect(context.stack[0].variables).toEqual({
			foo: "bar",
			baz: "qux",
		});
	});

	test("popStack removes frames with matching scope", () => {
		const manager = new StateManager(
			{ variables: {} },
			{
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signal: new AbortController().signal,
				settings: {
					useScoping: true,
				},
				config: { variables: {} },
			},
		);

		manager.pushStack({
			id: "test1",
			variables: { foo: "bar" },
			scope: GLOBAL_SCOPE,
		});

		manager.pushStack({
			id: "test2",
			variables: { baz: "qux" },
			scope: "local",
		});

		manager.popStack(GLOBAL_SCOPE);

		const context = manager.getRuntimeContext();
		expect(context.stack.length).toBe(1);
		expect(context.stack[0].scope).toBe("local");
	});

	test("setData correctly updates scoped data", () => {
		const manager = new StateManager(
			{ variables: {} },
			{
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signal: new AbortController().signal,
				settings: {
					useScoping: true,
				},
				config: { variables: {} },
			},
		);

		manager.setData({ foo: "bar" }, GLOBAL_SCOPE);
		expect(manager.getScopedVariables(GLOBAL_SCOPE)).toEqual({ foo: "bar" });

		manager.setData({ baz: "qux" }, GLOBAL_SCOPE);
		expect(manager.getScopedVariables(GLOBAL_SCOPE)).toEqual({
			foo: "bar",
			baz: "qux",
		});
	});

	test("addToTextRegistry adds text to correct scope", () => {
		const manager = new StateManager(
			{ variables: {} },
			{
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signal: new AbortController().signal,
				settings: {
					useScoping: true,
				},
				config: { variables: {} },
			},
		);

		manager.addToTextRegistry("test text", GLOBAL_SCOPE);
		expect(manager.getScopedText(GLOBAL_SCOPE)).toEqual(["test text"]);

		manager.addToTextRegistry("more text", GLOBAL_SCOPE);
		expect(manager.getScopedText(GLOBAL_SCOPE)).toEqual([
			"test text",
			"more text",
		]);
	});

	test("clearTextRegistry removes text from specified scope", () => {
		const manager = new StateManager(
			{ variables: {} },
			{
				plugins: [],
				adapters: [],
				variables: {},
				input: {},
				events: {},
				signal: new AbortController().signal,
				settings: {
					useScoping: true,
				},
				config: { variables: {} },
			},
		);

		manager.addToTextRegistry("test text", GLOBAL_SCOPE);
		manager.addToTextRegistry("local text", "local");

		manager.clearTextRegistry(GLOBAL_SCOPE);
		expect(manager.getScopedText(GLOBAL_SCOPE)).toEqual([]);
		expect(manager.getScopedText("local")).toEqual(["local text"]);
	});
});



================================================
File: tsconfig.build.json
================================================
{
	"extends": "./tsconfig.json",
	"compilerOptions": {
		"noEmit": false,
		"declaration": true,
		"emitDeclarationOnly": true,
		"outDir": "./dist",
		"paths": {
			"@/*": ["./dist/*"]
		}
	},
	"exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts"]
}



================================================
File: tsconfig.json
================================================
{
	"compilerOptions": {
		// Enable latest features
		"lib": ["ESNext", "DOM"],
		"target": "ESNext",
		"module": "ESNext",
		"moduleDetection": "force",
		"jsx": "react-jsx",
		"allowJs": true,

		// Bundler mode
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"verbatimModuleSyntax": true,
		"noEmit": true,

		// Best practices
		"strict": true,
		"skipLibCheck": true,
		"noFallthroughCasesInSwitch": true,

		// Some stricter flags (disabled by default)
		"noUnusedLocals": false,
		"noUnusedParameters": false,
		"noPropertyAccessFromIndexSignature": false,

		// Path aliases
		"baseUrl": ".",
		"rootDir": ".",
		"outDir": "./dist"
	},
	"include": ["./**/*.ts", "./**/*.tsx"],
	"exclude": ["node_modules", "dist"]
}



================================================
File: tsup.config.ts
================================================
import { defineConfig } from "tsup";

export default defineConfig({
	entry: ["index.ts"],
	format: ["cjs", "esm"],
	dts: true,
	clean: true,
	minify: true,
	outDir: "dist",
	sourcemap: false, // Disable sourcemaps to reduce bundle size
	splitting: true,
	treeshake: {
		preset: "recommended",
		moduleSideEffects: false, // Assume modules have no side effects for better tree shaking
	},
	noExternal: [], // Bundle all dependencies
	target: "es2020", // Target newer JS version for smaller output
	outExtension({ format }) {
		return {
			js: format === "cjs" ? ".js" : ".mjs",
		};
	},
	esbuildOptions(options) {
		options.assetNames = "[name]";
		options.drop = ["console", "debugger"]; // Remove console.logs and debugger statements
		options.pure = ["console.log"]; // Mark console.log calls as pure for removal
		options.legalComments = "none"; // Remove license comments

		// Remove mangleProps to prevent mangling of module names
		// options.mangleProps = /^_/

		options.minifyIdentifiers = true;
		options.minifySyntax = true;
		options.minifyWhitespace = true;

		// Add reserved names that shouldn't be minified
		options.keepNames = true;
		options.mangleQuoted = false; // Prevent mangling of quoted strings

		// Reserve specific identifiers from minification
		options.reserveProps = /^(load-vars|eval-code|aimVariables|evaluate)$/;
	},
});



================================================
File: types.ts
================================================
import type {
	Config,
	Node,
	RenderableTreeNodes,
	Schema,
} from "@markdoc/markdoc";
import type { CoreTool } from "ai";
import type { StructuredTool } from "langchain/tools";
import type { StateManager } from "runtime/state";
import type { z } from "zod";

export type StateBlock = {
	timestamp: number;
	action: string;
	hash: string;
	previousHash: string;
	state: RuntimeContext;
	diff: {
		stack: number;
		textRegistry: number;
		data: number;
	};
};

export type AIMConfig = Config;

export type AIMTag = Schema;

export type StackFrame = {
	/** Unique identifier for the stack frame */
	id: string;
	/** Scope for the stack frame */
	scope: string;
	/** Variables stored in this stack frame */
	variables: Record<string, any>;
};

export type RuntimeMethods = {
	/** Add a new frame to the execution stack */
	pushStack: (frame: {
		id: string;
		scope: string;
		variables: Record<string, any>;
	}) => void;
	/** Remove frames from the execution stack for a given scope */
	popStack: (params: { scope: string }) => void;
	/** Set data in the scoped store */
	setData: (params: { data: Record<string, any>; scope: string }) => void;
	/** Reset the runtime context to initial state */
	resetContext: () => void;
	/** Add text to the registry for AI context */
	addToTextRegistry: (params: { text: string; scope: string }) => void;
	/** Clear the text registry for a scope */
	clearTextRegistry: (params: { scope: string }) => void;
	/** Get current config with resolved variables */
	getCurrentConfig: (config: Config) => Promise<Config>;
	/** Get the current runtime context */
	getRuntimeContext: () => Promise<RuntimeContext>;
};

export type RuntimeContext = {
	/** Text registry for AI context, scoped by key */
	textRegistry: Record<string, string[]>;
	/** Stack of execution frames */
	stack: Array<StackFrame>;
	/** Global data store, scoped by key */
	data: Record<string, Record<string, any>>;
	/** Registered plugins */
	plugins: Map<string, AIMPlugin>;
	/** Registered adapters */
	adapters: Map<string, AIMAdapter>;
	/** Current configuration */
	config: AIMConfig;
};

export type RuntimeState = {
	/** Runtime options for execution */
	options: RuntimeOptions;
	/** Current runtime context state */
	context: RuntimeContext & {
		methods: RuntimeMethods;
	};
};

export type AIMRuntime = {
	/** Current Markdoc node being processed */
	node: Node;
	/** Runtime state and execution context */
	stateManager: StateManager;
};

export interface RuntimeOptions {
	config: Config;
	input?: { [key: string]: string | object | number };
	events?: {
		onLog?: (message: string) => void;
		onError?: (errorMessage: string) => void;
		onSuccess?: (successMessage: string) => void;
		onAbort?: (abortReason: string) => void;
		onFinish?: (finishMessage: string) => void;
		onStart?: (startMessage: string) => void;
		onStep?: (stepDescription: string) => void;
		onData?: (data: unknown) => void;
		onToolCall?: (name: string, args: unknown) => void;
		onOutput?: (output: {
			success: boolean;
			data?: unknown;
			type: "text" | "code" | "image" | "structured" | "error";
			content: string | object;
		}) => Promise<void>;
		onUserInput?: (prompt: string) => Promise<string>;
	};
	signals: {
		abort: AbortSignal;
	};
	settings: {
		useScoping: boolean;
	};
	env?: Record<string, string>;
	timeout?: number;
	maxRetries?: number;
	variables?: Record<string, unknown>;
	environment?: "node" | "browser";
	getReferencedFlow?: (flowId: string) => Promise<{ name: string } | null>;
	plugins?: Array<{ plugin: AIMPlugin; options?: unknown }>;
	adapters?: Array<AIMAdapter>;
	tools?: Record<string, StructuredTool | CoreTool | AIMTool>;
	experimental_files?: Record<string, {
		content: string;
	}>;
}

export interface AIMResult {
	ast: Node;
	errors: any[];
	warnings: any[];
	execute: (options: Partial<RuntimeOptions>) => Promise<any>;
}

export interface AIMOutput {
	success: boolean;
	data?: unknown;
	type: "text" | "code" | "image" | "structured" | "error";
	content: string | object;
}

export interface AIMAdapter {
	type: string;
	init?: () => void;
	handlers: Record<string, (...args: any[]) => Promise<any>>;
}

export interface AIMPlugin {
	name: string;
	version: string;
	description?: string;
	author?: string;
	license?: string;
	dependencies?: {
		plugins?: Array<{ name: string; versionRange: string }>;
		adapters?: Array<{ name: string; versionRange: string }>;
	};
	configSchema?: unknown; // Schema validation object (e.g., Zod, Joi, etc.)
	init?: (config: AIMConfig, pluginOptions?: unknown) => void;
	tags?: Record<
		string,
		AIMTag & {
			execute: (params: {
				node: Node;
				config: Config;
				state: RuntimeState;
			}) => AsyncGenerator<RenderableTreeNodes>;
		}
	>;
	functions?: Record<string, (...args: any[]) => any>;
	hooks?: {
		beforeExecution?: (context: RuntimeContext) => Promise<void>;
		afterExecution?: (context: RuntimeContext, result: any) => Promise<void>;
		onError?: (context: RuntimeContext, error: Error) => Promise<void>;
	};
}


export type AIMTool = {
	description: string;
	parameters: z.ZodObject<any>;
	execute: (args: any) => Promise<any>;
}



